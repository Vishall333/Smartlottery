<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Lottery Pro - India's Most Trusted Lottery Platform</title>
    <meta name="description" content="Join India's most trusted lottery platform with secure payments, fair play, and instant prize distribution.">

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <!-- Firebase SDK v9 -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js">
async function fetchWithdrawalHistory() {
    if (!currentUser) return;
    try {
        // First try to get withdrawals from user's transactions
        const userRef = db.collection('users').doc(currentUser.uid);
        const transactionsSnapshot = await userRef.collection('transactions')
            .where('type', '==', 'withdrawal')
            .orderBy('timestamp', 'desc')
            .get();

        let withdrawals = [];
        if (!transactionsSnapshot.empty) {
            withdrawals = transactionsSnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    timestamp: data.timestamp && data.timestamp.toDate ? data.timestamp.toDate() : data.timestamp
                };
            });
        }

        // Also check pending withdrawals collection
        const pendingSnapshot = await db
            .collection('pendingWithdrawals')
            .where('userId', '==', currentUser.uid)
            .orderBy('requestedAt', 'desc')
            .get();

        if (!pendingSnapshot.empty) {
            const pendingWithdrawals = pendingSnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    type: 'withdrawal',
                    amount: -Math.abs(data.amount),
                    description: data.description || `Withdrawal request - ${data.method || 'Bank'}`,
                    status: data.approvalStatus || 'pending_approval',
                    date: data.date,
                    time: data.time,
                    timestamp: data.requestedAt,
                    method: data.method,
                    upiId: data.upiId,
                    bankAccount: data.bankAccount,
                    ifscCode: data.ifscCode,
                    accountName: data.accountName
                };
            });

            // Merge with existing withdrawals, avoiding duplicates
            pendingWithdrawals.forEach(pw => {
                const exists = withdrawals.find(w => w.id === pw.id);
                if (!exists) {
                    withdrawals.unshift(pw);
                }
            });
        }

        withdrawalHistory = withdrawals;
        renderWithdrawalHistory();
    } catch (err) {
        console.error('Error fetching withdrawal history:', err);
        // Fallback to transactions array
        withdrawalHistory = transactions.filter(t => t.type === 'withdrawal');
        renderWithdrawalHistory();
    }
}

function renderWithdrawalHistory() {
    const container = document.getElementById('withdrawalHistory');
    if (!container) return;
    
    container.innerHTML = '';

    if (withdrawalHistory.length === 0) {
        container.innerHTML = `<div class="data-item"><div class="data-item-info"><div class="data-item-title">No withdrawals found.</div></div></div>`;
        return;
    }

    withdrawalHistory.forEach(entry => {
        const item = document.createElement('div');
        item.className = 'data-item';
        
        let statusClass = '';
        let statusText = '';

        switch (entry.status) {
            case 'pending_approval':
                statusClass = 'pending';
                statusText = 'Pending Approval';
                break;
            case 'approved':
                statusClass = 'approved';
                statusText = 'Approved';
                break;
            case 'processing':
                statusClass = 'processing';
                statusText = 'Processing';
                break;
            case 'completed':
                statusClass = 'verified';
                statusText = 'Completed';
                break;
            case 'rejected':
                statusClass = 'rejected';
                statusText = 'Rejected';
                break;
            default:
                statusClass = 'pending';
                statusText = entry.status || 'Processing';
        }

        const statusBadge = `<span class="payment-verification-badge ${statusClass}">${statusText}</span>`;

        item.innerHTML = `
            <div class="data-item-info">
                <div class="data-item-title">₹${Math.abs(entry.amount).toLocaleString()} - ${(entry.method || 'Bank').toUpperCase()}${statusBadge}</div>
                <div class="data-item-subtitle">${entry.description || 'Withdrawal request'}</div>
                <div class="data-item-subtitle">${entry.date || 'Recent'} • ${entry.time || ''}</div>
            </div>
            <div class="data-item-value transaction-amount negative">
                -₹${Math.abs(entry.amount).toLocaleString()}
            </div>
        `;
        container.appendChild(item);
    });
}

</script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-functions-compat.js"></script>

    <!-- EmailJS SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>

    <!-- Cashfree SDK -->
    <script src="https://sdk.cashfree.com/js/v3/cashfree.js"></script>

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <style>
        :root {
            --primary: #0052cc;
            --primary-light: #1976d2;
            --primary-dark: #003d99;
            --secondary: #64748b;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --accent: #7c3aed;
            --background: #f8fafc;
            --surface: #ffffff;
            --text: #1e293b;
            --text-light: #64748b;
            --text-lighter: #94a3b8;
            --border: #e2e8f0;
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --radius: 8px;
            --radius-lg: 12px;
            --transition: all 0.2s ease-in-out;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--background);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header Styles */
        .header {
            text-align: center;
            padding: 60px 20px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            color: white;
            margin-bottom: 40px;
            border-radius: var(--radius-lg);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="stars" patternUnits="userSpaceOnUse" width="10" height="10"><circle cx="5" cy="5" r="1" fill="rgba(255,255,255,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23stars)"/></svg>');
            animation: float 20s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateX(0px); }
            50% { transform: translateX(20px); }
        }

        .header-content {
            position: relative;
            z-index: 1;
        }

        .logo {
            font-family: 'Poppins', sans-serif;
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .tagline {
            font-size: 1.2rem;
            font-weight: 400;
            opacity: 0.95;
            margin-bottom: 30px;
        }

        .trust-badges {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .trust-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.15);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* User Section */
        .user-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--surface);
            padding: 25px 30px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            margin-bottom: 40px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-avatar {
            width: 50px;
            height: 50px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 1.3rem;
        }

        .user-details h3 {
            margin: 0;
            color: var(--text);
            font-size: 1.2rem;
        }

        .user-balance {
            color: var(--success);
            font-weight: 600;
            font-size: 1rem;
        }

        .user-email {
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .user-actions {
            display: flex;
            gap: 15px;
        }

        /* Tabs - Improved spacing */
        .tab-navigation {
            display: flex;
            background: var(--surface);
            border-radius: var(--radius-lg);
            padding: 15px;
            margin-bottom: 50px;
            box-shadow: var(--shadow);
            overflow-x: auto;
            gap: 12px;
        }

        .tab-btn {
            flex: 1;
            padding: 18px 30px;
            border: none;
            background: transparent;
            color: var(--text-light);
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            min-width: 160px;
            font-weight: 500;
            font-size: 1rem;
        }

        .tab-btn.active {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .tab-btn:hover:not(.active) {
            background: var(--background);
            color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Live Stats */
        .live-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 30px;
            margin-bottom: 60px;
        }

        .live-stat {
            background: var(--surface);
            padding: 35px 30px;
            border-radius: var(--radius-lg);
            text-align: center;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .live-stat:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
        }

        .live-stat-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            color: var(--primary);
        }

        .live-stat-value {
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .live-stat-label {
            font-size: 1rem;
            color: var(--text-light);
            font-weight: 500;
        }

        /* Buttons */
        .btn {
            padding: 16px 32px;
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            min-height: 54px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-secondary:hover {
            background: #475569;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-outline {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
        }

        .btn-outline:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        .btn-full {
            width: 100%;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Cards */
        .card {
            background: var(--surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .card:hover {
            box-shadow: var(--shadow-lg);
        }

        /* Contest Cards - Better spacing */
        .contest-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 40px;
            margin-bottom: 60px;
        }

        .contest-card {
            padding: 35px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            border-radius: var(--radius-lg);
        }

        .contest-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
        }

        .contest-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .contest-title i {
            color: var(--primary);
        }

        .contest-prize {
            font-size: 3rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rupee-symbol {
            font-size: 2.4rem;
            opacity: 0.8;
        }

        .contest-details {
            margin-bottom: 30px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .detail-label {
            color: var(--text-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .detail-value {
            font-weight: 600;
            color: var(--text);
        }

        .progress-bar {
            background: rgba(0,0,0,0.1);
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            transition: width 0.3s ease;
        }

        /* Prize Distribution */
        .prize-distribution {
            margin-bottom: 30px;
        }

        .prize-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
        }

        .prize-details {
            margin-top: 20px;
            display: none;
            background: rgba(0, 82, 204, 0.05);
            padding: 25px;
            border-radius: var(--radius);
        }

        .prize-details.show {
            display: block;
        }

        .prize-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(0, 82, 204, 0.1);
        }

        .prize-item:last-child {
            border-bottom: none;
        }

        .prize-position {
            font-weight: 600;
            color: var(--primary);
        }

        .prize-amount {
            font-weight: 700;
            color: var(--success);
        }

        /* Forms */
        .form-group {
            margin-bottom: 25px;
        }

        .form-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
            color: var(--text);
        }

        .form-input {
            width: 100%;
            padding: 18px 20px;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            font-size: 1rem;
            transition: var(--transition);
            background: var(--surface);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 82, 204, 0.1);
        }

        .password-input-container {
            position: relative;
        }

        .password-toggle {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            padding: 6px;
        }

        .amount-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 18px;
            margin-bottom: 25px;
        }

        .amount-btn {
            padding: 18px;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .amount-btn:hover {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        /* UPI Options */
        .upi-options {
            margin: 20px 0;
            padding: 20px;
            background: var(--background);
            border-radius: var(--radius);
        }

        .upi-option {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            background: var(--surface);
        }

        .upi-option:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .upi-option input[type="radio"] {
            margin: 0;
            width: 18px;
            height: 18px;
        }

        .upi-option.selected {
            border-color: var(--primary);
            background: rgba(0, 82, 204, 0.05);
            box-shadow: var(--shadow);
        }

        .upi-option-content {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .upi-option-icon {
            font-size: 1.8rem;
        }

        .upi-option-text {
            flex: 1;
        }

        .upi-option-name {
            font-weight: 600;
            color: var(--text);
            margin-bottom: 2px;
        }

        .upi-option-desc {
            font-size: 0.85rem;
            color: var(--text-light);
        }

        /* UPI QR Code */
        .upi-qr-container {
            text-align: center;
            padding: 30px;
            background: var(--surface);
            border-radius: var(--radius);
            margin: 20px 0;
            border: 2px dashed var(--border);
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            padding: 20px;
        }

        .modal-content {
            background: var(--surface);
            max-width: 500px;
            margin: 50px auto;
            border-radius: var(--radius-lg);
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            padding: 30px 30px 20px;
            border-bottom: 1px solid var(--border);
        }

        .modal-header h2 {
            margin: 0;
            color: var(--text);
            font-size: 1.5rem;
        }

        .modal-close {
            position: absolute;
            top: 25px;
            right: 25px;
            background: none;
            border: none;
            font-size: 1.6rem;
            color: var(--text-light);
            cursor: pointer;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: var(--transition);
        }

        .modal-close:hover {
            background: var(--border);
        }

        .modal-body {
            padding: 30px;
        }

        /* Terms and Conditions Styles */
        .terms-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 20px;
            margin: 20px 0;
            background: var(--background);
        }

        .terms-container h3 {
            color: var(--primary);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .terms-container h3:first-child {
            margin-top: 0;
        }

        .terms-checkbox {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin: 20px 0;
        }

        .terms-checkbox input[type="checkbox"] {
            margin-top: 5px;
            width: 18px;
            height: 18px;
        }

        .otp-container {
            text-align: center;
            padding: 20px;
            background: var(--background);
            border-radius: var(--radius);
            margin: 20px 0;
        }

        .otp-input {
            width: 60px;
            height: 60px;
            text-align: center;
            font-size: 1.5rem;
            margin: 0 10px;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            background: var(--surface);
        }

        .otp-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 82, 204, 0.1);
        }

        /* Auth Forms */
        .auth-container {
            max-width: 450px;
            margin: 0 auto;
            padding: 50px 20px;
        }

        .auth-card {
            background: var(--surface);
            padding: 50px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
        }

        .auth-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .auth-header h2 {
            color: var(--text);
            margin-bottom: 10px;
        }

        .auth-header p {
            color: var(--text-light);
        }

        .auth-toggle {
            text-align: center;
            margin-top: 25px;
        }

        .auth-toggle a {
            color: var(--primary);
            text-decoration: none;
            font-weight: 500;
        }

        .auth-toggle a:hover {
            text-decoration: underline;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 25px;
            right: 25px;
            padding: 18px 24px;
            border-radius: var(--radius);
            color: white;
            font-weight: 500;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 400px;
            box-shadow: var(--shadow-lg);
            animation: slideIn 0.3s ease;
        }

        .notification.success {
            background: var(--success);
        }

        .notification.error {
            background: var(--error);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Loading */
        .loading-section {
            display: none;
            text-align: center;
            padding: 80px 20px;
            color: var(--text-light);
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--border);
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 25px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Data Lists */
        .data-list {
            background: var(--surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .data-item {
            padding: 25px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .data-item:last-child {
            border-bottom: none;
        }

        .data-item-info {
            flex: 1;
        }

        .data-item-title {
            font-weight: 600;
            color: var(--text);
            margin-bottom: 6px;
        }

        .data-item-subtitle {
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .data-item-value {
            font-weight: 700;
            color: var(--primary);
        }

        .transaction-amount.positive {
            color: var(--success);
        }

        .transaction-amount.negative {
            color: var(--error);
        }

        /* Profile Section */
        .profile-section {
            background: var(--surface);
            padding: 40px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            margin-bottom: 40px;
        }

        .profile-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
            margin-top: 40px;
        }

        .profile-stat {
            text-align: center;
            padding: 25px;
            background: var(--background);
            border-radius: var(--radius);
        }

        .profile-stat-value {
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .profile-stat-label {
            color: var(--text-light);
            font-weight: 500;
        }

        /* Payment Summary */
        .payment-summary {
            background: var(--background);
            padding: 25px;
            border-radius: var(--radius);
            margin-bottom: 25px;
        }

        .summary-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .summary-row:last-child {
            border-top: 1px solid var(--border);
            padding-top: 15px;
            font-weight: 700;
            font-size: 1.2rem;
        }

        /* Joined Contest Styles */
        .joined-contest-card {
            background: var(--surface);
            padding: 25px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            margin-bottom: 20px;
            border-left: 5px solid var(--primary);
        }

        .joined-contest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .joined-contest-title {
            font-weight: 600;
            color: var(--text);
            font-size: 1.2rem;
        }

        .joined-contest-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .status-joined {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .status-completed {
            background: rgba(100, 116, 139, 0.1);
            color: var(--secondary);
        }

        .status-won {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }

        .joined-contest-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .joined-detail {
            text-align: center;
        }

        .joined-detail-label {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-bottom: 5px;
        }

        .joined-detail-value {
            font-weight: 600;
            color: var(--text);
        }

        .payment-verification-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 8px;
        }

        .verified {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .pending {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }

        .failed {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error);
        }

        .processing {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }

        .approved {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .rejected {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .header {
                padding: 50px 20px;
                margin-bottom: 30px;
            }

            .logo {
                font-size: 2.2rem;
            }```text

            .tagline {
                font-size: 1.1rem;
            }

            .user-header {
                padding: 20px 25px;
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }

            .user-actions {
                flex-direction: row;
                justify-content: center;
                gap: 15px;
            }

            .contest-grid {
                grid-template-columns: 1fr;
                gap: 30px;
            }

            .live-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 20px;
            }

            .modal {
                padding: 15px;
            }

            .auth-card {
                padding: 40px 30px;
            }

            .amount-buttons {
                grid-template-columns: repeat(2, 1fr);
            }

            .tab-navigation {
                padding: 10px;
            }

            .tab-btn {
                padding: 16px 20px;
                font-size: 0.9rem;
                min-width: 120px;
            }
        }

        /* Hide sections initially */
        #authSection,
        #userSection {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Landing Section -->
    <div id="landingSection">
        <div class="container">
            <div class="header">
                <div class="header-content">
                    <h1 class="logo">Smart Lottery Pro</h1>
                    <p class="tagline">India's Most Trusted Lottery Platform</p>
                    <button class="btn btn-success" onclick="showAuth()" style="font-size: 1.2rem; padding: 18px 36px;">
                        <i class="fas fa-rocket"></i> Join Now & Win Big
                    </button>
                    <div class="trust-badges">
                        <div class="trust-badge">
                            <i class="fas fa-shield-alt"></i> 100% Secure
                        </div>
                        <div class="trust-badge">
                            <i class="fas fa-bolt"></i> Instant Payouts
                        </div>
                        <div class="trust-badge">
                            <i class="fas fa-users"></i> 50,000+ Winners
                        </div>
                    </div>
                </div>
            </div>

            <!-- Live Stats -->
            <div class="live-stats">
                <div class="live-stat">
                    <div class="live-stat-icon">
                        <i class="fas fa-users"></i>
                    </div>
                    <div class="live-stat-value" id="totalUsers">45,287</div>
                    <div class="live-stat-label">Active Players</div>
                </div>
                <div class="live-stat">
                    <div class="live-stat-icon">
                        <i class="fas fa-trophy"></i>
                    </div>
                    <div class="live-stat-value" id="totalPrizes">₹12.5L</div>
                    <div class="live-stat-label">Prizes Distributed</div>
                </div>
                <div class="live-stat">
                    <div class="live-stat-icon">
                        <i class="fas fa-crown"></i>
                    </div>
                    <div class="live-stat-value" id="winnersToday">127</div>
                    <div class="live-stat-label">Winners Today</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Auth Section -->
    <div id="authSection">
        <div class="auth-container">
            <div class="auth-card">
                <!-- Terms and Conditions Agreement -->
                <div id="termsAgreement">
                    <div class="auth-header">
                        <h2>Terms & Conditions</h2>
                        <p>Please read and accept our terms before proceeding</p>
                    </div>

                    <div class="terms-container">
                        <h3>1. Platform Overview</h3>
                        <p>Smart Lottery Pro is a digital lottery platform works as per the Information Technology Act, 2000 and operates in compliance with applicable Indian laws. Our platform provides fair, transparent, and secure lottery services to users across India.</p>

                        <h3>2. Eligibility</h3>
                        <p>You must be at least 18 years old and a legal resident of India to participate. Participation is prohibited in states where online lotteries are banned. By registering, you confirm your eligibility and legal capacity to enter into this agreement.</p>

                        <h3>3. Registration & Account Security</h3>
                        <p>You must provide accurate, complete information during registration. You are responsible for maintaining account confidentiality and all activities under your account. Email verification is mandatory for account activation.</p>

                        <h3>4. Payment & Transactions</h3>
                        <p>All payments are processed through secure, licensed payment gateways (Cashfree). Deposits are non-refundable once lottery tickets are purchased. Winnings are credited automatically upon result declaration. Minimum withdrawal is ₹500.</p>

                        <h3>5. Fair Play & Transparency</h3>
                        <p>All lottery draws use certified random number generation systems. Results are transparent and verifiable. No manipulation or fraud is tolerated. Winners are selected based purely on chance and luck.</p>

                        <h3>6. Taxation</h3>
                        <p>Winners are responsible for applicable taxes as per Indian Income Tax laws. TDS will be deducted for winnings above ₹1,00,000 as per government regulations. We provide necessary tax certificates.</p>

                        <h3>7. Responsible Gaming</h3>
                        <p>We promote responsible gaming. Please play within your means. If you feel you have a gambling problem, please seek help. We reserve the right to suspend accounts showing signs of problem gambling.</p>

                        <h3>8. Privacy & Data Protection</h3>
                        <p>We protect your personal data as per our Privacy Policy and Indian data protection laws. Your information is never shared with third parties without consent, except as required by law.</p>

                        <h3>9. Dispute Resolution</h3>
                        <p>Any disputes will be resolved through arbitration in accordance with Indian Arbitration laws. The jurisdiction will be Mumbai, Maharashtra. Customer support is available 24/7 for assistance.</p>

                        <h3>10. Platform Availability</h3>
                        <p>We strive for 99.9% uptime but cannot guarantee uninterrupted service. Maintenance windows will be announced in advance. No liability for temporary service disruptions.</p>
                    </div>

                    <div class="terms-checkbox">
                        <input type="checkbox" id="acceptTerms" required>
                        <label for="acceptTerms">I have read, understood, and agree to the Terms & Conditions, Privacy Policy, and confirm that I am 18+ years old and legally eligible to participate in online lotteries.</label>
                    </div>

                    <button class="btn btn-primary btn-full" onclick="proceedToAuth()" id="proceedBtn" disabled>
                        <i class="fas fa-check-circle"></i> Accept & Continue
                    </button>
                </div>

                <!-- Login Form -->
                <div id="loginForm" style="display: none;">
                    <div class="auth-header">
                        <h2>Welcome Back</h2>
                        <p>Sign in to continue your winning journey</p>
                    </div>
                    <form onsubmit="handleLogin(event)">
                        <div class="form-group">
                            <label class="form-label">Email Address</label>
                            <input type="email" class="form-input" id="loginEmail" required placeholder="Enter your email">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Password</label>
                            <div class="password-input-container">
                                <input type="password" class="form-input" id="loginPassword" required placeholder="Enter your password">
                                <button type="button" class="password-toggle" onclick="togglePasswordVisibility('loginPassword')">
                                    <i class="fas fa-eye"></i>
                                </button>
                            </div>
                        </div>
                        <button type="submit" class="btn btn-primary btn-full">
                            <i class="fas fa-sign-in-alt"></i> Sign In
                        </button>
                    </form>
                    <div class="auth-toggle">
                        Don't have an account? <a href="#" onclick="toggleAuthForm('signup')">Sign Up</a>
                    </div>
                </div>

                <!-- Signup Form -->
                <div id="signupForm" style="display: none;">
                    <div class="auth-header">
                        <h2>Join Smart Lottery</h2>
                        <p>Create your account and start winning</p>
                    </div>
                    <form onsubmit="handleSignup(event)">
                        <div class="form-group">
                            <label class="form-label">Full Name</label>
                            <input type="text" class="form-input" id="signupName" required placeholder="Enter your full name">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Email Address</label>
                            <input type="email" class="form-input" id="signupEmail" required placeholder="Enter your email">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Password</label>
                            <div class="password-input-container">
                                <input type="password" class="form-input" id="signupPassword" required placeholder="Create a strong password" minlength="6">
                                <button type="button" class="password-toggle" onclick="togglePasswordVisibility('signupPassword')">
                                    <i class="fas fa-eye"></i>
                                </button>
                            </div>
                        </div>
                        <button type="submit" class="btn btn-primary btn-full">
                            <i class="fas fa-user-plus"></i> Create Account
                        </button>
                    </form>
                    <div class="auth-toggle">
                        Already have an account? <a href="#" onclick="toggleAuthForm('login')">Sign In</a>
                    </div>
                </div>

                <!-- Email OTP Verification -->
                <div id="otpVerification" style="display: none;">
                    <div class="auth-header">
                        <h2>Verify Your Email</h2>
                        <p>Enter the 6-digit code sent to your email</p>
                    </div>

                    <div class="otp-container">
                        <input type="text" class="otp-input" maxlength="1" id="otp1" oninput="moveToNext(this, 'otp2')">
                        <input type="text" class="otp-input" maxlength="1" id="otp2" oninput="moveToNext(this, 'otp3')">
                        <input type="text" class="otp-input" maxlength="1" id="otp3" oninput="moveToNext(this, 'otp4')">
                        <input type="text" class="otp-input" maxlength="1" id="otp4" oninput="moveToNext(this, 'otp5')">
                        <input type="text" class="otp-input" maxlength="1" id="otp5" oninput="moveToNext(this, 'otp6')">
                        <input type="text" class="otp-input" maxlength="1" id="otp6" oninput="moveToNext(this, null)">
                    </div>

                    <button class="btn btn-primary btn-full" onclick="verifyOTP()">
                        <i class="fas fa-check-circle"></i> Verify Email
                    </button>

                    <div class="auth-toggle">
                        Didn't receive code? <a href="#" onclick="resendOTP()">Resend OTP</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- User Section -->
    <div id="userSection">
        <div class="container">
            <!-- User Header -->
            <div class="user-header">
                <div class="user-info">
                    <div class="user-avatar" id="userAvatar">U</div>
                    <div class="user-details">
                        <h3 id="userDisplayName">Smart Player</h3>
                        <div class="user-email" id="userEmail">user@example.com</div>
                        <div class="user-balance">Balance: <span id="userBalance">₹0</span></div>
                    </div>
                </div>
                <div class="user-actions">
                    <button class="btn btn-success" onclick="openModal('addMoneyModal')">
                        <i class="fas fa-plus"></i> Add Money
                    </button>
                    <button class="btn btn-outline" onclick="handleLogout()">
                        <i class="fas fa-sign-out-alt"></i> Logout
                    </button>
                </div>
            </div>

            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-btn active" onclick="switchTab('contests')">
                    <i class="fas fa-trophy"></i> Live Contests
                </button>
                <button class="tab-btn" onclick="switchTab('joinedContests')">
                    <i class="fas fa-list"></i> My Contests
                </button>
                <button class="tab-btn" onclick="switchTab('winners')">
                    <i class="fas fa-crown"></i> Winners
                </button>
                <button class="tab-btn" onclick="switchTab('transactions')">
                    <i class="fas fa-exchange-alt"></i> Transactions
                </button>
                <button class="tab-btn" onclick="switchTab('profile')">
                    <i class="fas fa-user"></i> Profile
                </button>
                <button class="tab-btn" onclick="switchTab('withdrawal')">
                    <i class="fas fa-money-bill-wave"></i> Withdraw
                </button>
                <button class="tab-btn" onclick="switchTab('admin')" id="adminTab" style="display: none;">
                    <i class="fas fa-crown"></i> Admin
                </button>
            </div>

            <!-- Tab Contents -->
            <div id="contestsTab" class="tab-content active">
                <div class="contest-grid" id="contestGrid">
                    <!-- Contest cards will be rendered here -->
                </div>
            </div>

            <div id="joinedContestsTab" class="tab-content">
                <!-- Active Contests Section -->
                <div style="margin-bottom: 40px;">
                    <h3 style="color: var(--primary); margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-play-circle"></i> Active Contests
                    </h3>
                    <div id="activeJoinedContestsList">
                        <!-- Active joined contests will be rendered here -->
                    </div>
                </div>

                <!-- Completed Contests Section -->
                <div>
                    <h3 style="color: var(--secondary); margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-check-circle"></i> Completed Contests
                    </h3>
                    <div id="completedJoinedContestsList">
                        <!-- Completed joined contests will be rendered here -->
                    </div>
                </div>
            </div>

            <div id="winnersTab" class="tab-content">
                <div id="winnersList" class="data-list">
                    <!-- Winners will be rendered here -->
                </div>
            </div>

            <div id="transactionsTab" class="tab-content">
                <div id="transactionsList" class="data-list">
                    <!-- Transactions will be rendered here -->
                </div>
            </div>

            <div id="profileTab" class="tab-content">
                <div class="profile-section">
                    <h2>Your Profile</h2>
                    <div class="profile-stats">
                        <div class="profile-stat">
                            <div class="profile-stat-value" id="profileContestsJoined">0</div>
                            <div class="profile-stat-label">Contests Joined</div>
                        </div>
                        <div class="profile-stat">
                            <div class="profile-stat-value" id="profileContestsWon">0</div>
                            <div class="profile-stat-label">Contests Won</div>
                        </div>
                        <div class="profile-stat">
                            <div class="profile-stat-value" id="profileTotalWinnings">₹0</div>
                            <div class="profile-stat-label">Total Winnings</div>
                        </div>
                        <div class="profile-stat">
                            <div class="profile-stat-value" id="profileWinRate">0%</div>
                            <div class="profile-stat-label">Win Rate</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="withdrawalTab" class="tab-content">
                <div class="profile-section">
                    <h2>Withdraw Money</h2>
                    <p style="margin-bottom: 25px; color: var(--text-light);">Withdraw your winnings to your bank account or UPI</p>

                    <div class="form-group">
                        <label class="form-label">Withdrawal Amount</label>
                        <input type="number" class="form-input" id="withdrawalAmount" min="500" placeholder="Minimum ₹500">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Withdrawal Method</label>
                        <div class="upi-options">
                            <div class="upi-option selected">
                                <input type="radio" name="withdrawalMethod" value="netbanking" checked>
                                <div class="upi-option-content">
                                    <i class="fas fa-university upi-option-icon" style="color: #007bff;"></i>
                                    <div class="upi-option-text">
                                        <div class="upi-option-name">Net Banking</div>
                                        <div class="upi-option-desc">Transfer to bank account via IMPS/NEFT or UPI</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="bankWithdrawalFields">
                        <div class="form-group">
                            <label class="form-label">Bank Account Number</label>
                            <input type="text" class="form-input" id="withdrawalAccount" placeholder="Enter your account number">
                        </div>

                        <div class="form-group">
                            <label class="form-label">IFSC Code</label>
                            <input type="text" class="form-input" id="withdrawalIFSC" placeholder="Enter IFSC code">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Account Holder Name</label>
                            <input type="text" class="form-input" id="withdrawalAccountName" placeholder="Enter account holder name">
                        </div>

                        <div class="form-group">
                            <label class="form-label">UPI ID (Optional - for faster transfers)</label>
                            <input type="text" class="form-input" id="withdrawalUPI" placeholder="yourname@upi (e.g., 9876543210@paytm)">
                        </div>
                    </div>

                    <button class="btn btn-primary btn-full" onclick="handleWithdrawal()">
                        <i class="fas fa-money-bill-wave"></i> Request Withdrawal
                    </button>

                    <div style="margin-top: 25px; padding: 20px; background: var(--background); border-radius: var(--radius); font-size: 0.95rem; color: var(--text-light);">
                        <strong>Note:</strong> Withdrawals require admin approval and are processed within 24-48 hours. Providing UPI ID can enable faster transfers (2-4 hours). Minimum withdrawal amount is ₹500.
                    </div>

                    <!-- Withdrawal History -->
                    <div style="margin-top: 40px;">
                        <h3 style="margin-bottom: 20px; color: var(--primary);">
                            <i class="fas fa-history"></i> Withdrawal History
                        </h3>
                        <div id="withdrawalHistory" class="data-list">
                            <!-- Withdrawal history will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>

            <div id="adminTab" class="tab-content">
                <div class="profile-section">
                    <h2>Admin Panel</h2>
                    <p style="margin-bottom: 25px; color: var(--text-light);">Manage contests, approve withdrawals, and oversee operations</p>

                    <!-- Tab Navigation for Admin -->
                    <div style="display: flex; gap: 20px; margin-bottom: 30px; border-bottom: 2px solid var(--border); padding-bottom: 15px;">
                        <button class="btn btn-outline" onclick="switchAdminTab('contests')" id="adminContestsBtn" style="background: var(--primary); color: white;">
                            <i class="fas fa-trophy"></i> Contest Management
                        </button>
                        <button class="btn btn-outline" onclick="switchAdminTab('withdrawals')" id="adminWithdrawalsBtn">
                            <i class="fas fa-money-bill-wave"></i> Withdrawal Approvals
                        </button>
                    </div>

                    <div id="adminContestsSection">
                        <div class="contest-management">
                            <h3>Contest Management</h3>
                            <div id="adminContestsList">
                                <!-- Admin contest controls will be rendered here -->
                            </div>
                        </div>
                    </div>

                    <div id="adminWithdrawalsSection" style="display: none;">
                        <div class="withdrawal-management">
                            <h3>Pending Withdrawal Approvals</h3>
                            <div id="adminWithdrawalsList">
                                <!-- Admin withdrawal approvals will be rendered here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div></div>
        </div>
    </div>

    <!-- Loading Section -->
    <div id="loadingSection" class="loading-section">
        <div class="loading-spinner"></div>
        <p>Loading your lottery experience...</p>
    </div>

    <!-- Add Money Modal -->
    <div id="addMoneyModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Add Money to Wallet</h2>
                <button class="modal-close" onclick="closeModal('addMoneyModal')">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Select Amount</label>
                    <div class="amount-buttons">
                        <button class="amount-btn" onclick="setAmount(100)">₹100</button>
                        <button class="amount-btn" onclick="setAmount(500)">₹500</button>
                        <button class="amount-btn" onclick="setAmount(1000)">₹1,000</button>
                        <button class="amount-btn" onclick="setAmount(2000)">₹2,000</button>
                        <button class="amount-btn" onclick="setAmount(5000)">₹5,000</button>
                        <button class="amount-btn" onclick="setAmount(10000)">₹10,000</button>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Or Enter Custom Amount</label>
                    <input type="number" class="form-input" id="amountInput" min="10" max="50000" placeholder="Enter amount (₹10 - ₹50,000)" oninput="updatePaymentSummary()">
                </div>

                <div class="form-group">
                    <label class="form-label">Select Payment Method</label>
                    <div class="upi-options">
                        <div class="upi-option selected" onclick="selectUPIMethod('gpay')">
                            <input type="radio" name="upiMethod" value="gpay" checked>
                            <div class="upi-option-content">
                                <i class="fab fa-google-pay upi-option-icon" style="color: #34a853;"></i>
                                <div class="upi-option-text">
                                    <div class="upi-option-name">Google Pay</div>
                                    <div class="upi-option-desc">Pay with Google Pay UPI</div>
                                </div>
                            </div>
                        </div>
                        <div class="upi-option" onclick="selectUPIMethod('phonepe')">
                            <input type="radio" name="upiMethod" value="phonepe">
                            <div class="upi-option-content">
                                <i class="fas fa-mobile-alt upi-option-icon" style="color: #5f2c8e;"></i>
                                <div class="upi-option-text">
                                    <div class="upi-option-name">PhonePe</div>
                                    <div class="upi-option-desc">Pay with PhonePe UPI</div>
                                </div>
                            </div>
                        </div>
                        <div class="upi-option" onclick="selectUPIMethod('paytm')">
                            <input type="radio" name="upiMethod" value="paytm">
                            <div class="upi-option-content">
                                <i class="fas fa-wallet upi-option-icon" style="color: #0f4685;"></i>
                                <div class="upi-option-text">
                                    <div class="upi-option-name">Paytm</div>
                                    <div class="upi-option-desc">Pay with Paytm UPI</div>
                                </div>
                            </div>
                        </div>
                        <div class="upi-option" onclick="selectUPIMethod('card')">
                            <input type="radio" name="upiMethod" value="card">
                            <div class="upi-option-content">
                                <i class="fas fa-credit-card upi-option-icon" style="color: #ff6900;"></i>
                                <div class="upi-option-text">
                                    <div class="upi-option-name">Debit/Credit Card</div>
                                    <div class="upi-option-desc">Pay with Bank Card</div>
                                </div>
                            </div>
                        </div>
                        <div class="upi-option" onclick="selectUPIMethod('netbanking')">
                            <input type="radio" name="upiMethod" value="netbanking">
                            <div class="upi-option-content">
                                <i class="fas fa-university upi-option-icon" style="color: #007bff;"></i>
                                <div class="upi-option-text">
                                    <div class="upi-option-name">Net Banking</div>
                                    <div class="upi-option-desc">Pay with Internet Banking</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="payment-summary">
                    <div class="summary-row">
                        <span>You Pay:</span>
                        <span id="totalAmount">₹0</span>
                    </div>
                    <div class="summary-row">
                        <span>Added to Wallet:</span>
                        <span id="paymentAmount">₹0</span>
                    </div>
                    <div style="font-size: 0.85rem; color: var(--text-light); text-align: center; margin-top: 10px; padding: 10px; background: rgba(0, 82, 204, 0.05); border-radius: var(--radius);">
                        <i class="fas fa-info-circle"></i> 2% payment gateway fee is deducted from your payment
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Your Email (Required for payment receipt)</label>
                    <input type="email" class="form-input" id="paymentEmail" placeholder="Enter your email for receipt" required>
                </div>

                <button class="btn btn-success btn-full" onclick="handlePayment()">
                    <i class="fas fa-credit-card"></i> Proceed to Payment
                </button>
            </div>
        </div>
    </div>

    <!-- UPI Payment Modal -->
    <div id="upiPaymentModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>UPI Payment</h2>
                <button class="modal-close" onclick="closeModal('upiPaymentModal')">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="upi-qr-container" id="upiQRCode">
                    <div>
                        <strong>Scan QR Code with any UPI app</strong>
                        <div class="upi-id-display" id="upiIdDisplay">smartlottery@paytm</div>
                        <p style="color: var(--text-light); margin: 10px 0;">Amount: <strong id="upiAmount">₹0</strong></p>
                        <p style="color: var(--text-light); font-size: 0.9rem;">
                            Open your UPI app (Google Pay, PhonePe, Paytm, etc.) and scan the QR code above or pay to the UPI ID
                        </p>
                    </div>
                </div>
                <div style="display: flex; gap: 15px; margin-top: 25px;">
                    <button class="btn btn-outline" onclick="copyUPIId()" style="flex: 1;">
                        <i class="fas fa-copy"></i> Copy UPI ID
                    </button>
                    <button class="btn btn-success" onclick="confirmUPIPayment()" style="flex: 1;">
                        <i class="fas fa-check"></i> Payment Done
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBXeD8SMXHnqhNDg01Rlm4fC1t05Eb4NFs",
            authDomain: "smart-lottery-b08c5.firebaseapp.com",
            projectId: "smart-lottery-b08c5",
            storageBucket: "smart-lottery-b08c5.appspot.com",
            messagingSenderId: "1038545058004",
            appId: "1:1038545058004:web:65b29c57eda2939f18e341",
            measurementId: "G-SH9Y19ZE74"
        };

        // API Configuration for Firebase Functions
        const API_BASE_URL = 'https://api-2uuq6sr6qa-uc.a.run.app';
        // UPI Configuration
        const UPI_CONFIG = {
            merchantId: 'smartlottery@paytm',
            merchantName: 'Smart Lottery Pro',
            merchantCode: 'LOTTERY',
            qrCodeUrl: 'https://api.qrserver.com/v1/create-qr-code/'
        };

        // Global variables
        let currentUser = null;
        let userBalance = 0;
        let auth, db, functions, cashfree;
        let isAdmin = false;
        let currentPaymentAmount = 0;
        let currentPaymentMethod = 'gpay';
        let userProfile = {
            contestsJoined: 0,
            contestsWon: 0,
            totalWinnings: 0
        };
        let transactions = [];
        let winners = [];
        let activeContests = [];
        let joinedContests = [];
        let withdrawalHistory = [];
        let pendingWithdrawals = [];
        let pendingUserData = null; // Store user data during email verification
        let currentWithdrawalMethod = 'netbanking';

        // Admin emails
        const ADMIN_EMAILS = ['vishuu7306@gmail.com'];

        // Contest templates with dynamic lifecycle schedules and compensation prizes
        const CONTEST_TEMPLATES = [
            {
                id: 'ultimate_crorepati',
                title: 'Ultimate Crorepati',
                entryFee: 1000,
                maxParticipants: 10000,
                prizePool: 10000000,
                cycleDuration: 9 * 24 * 60 * 60 * 1000, // 9 days in milliseconds
                drawTime: '18:00', // 6 PM
                description: 'The ultimate lottery experience! Win up to ₹1 CRORE - the biggest jackpot in Indian online lottery history!',
                prizeStructure: [
                    { position: '1st Prize', amount: 5000000, percentage: '50%' },
                    { position: '2nd Prize', amount: 2500000, percentage: '25%' },
                    { position: '3rd Prize', amount: 1000000, percentage: '10%' },
                    { position: '4th Prize (Compensation * 625)', amount: 2000, percentage: 'For Real Winners' }
                ],
                compensationPrizes: {
                    total: 625,
                    amount: 2000,
                    realWinners: 3 // Maximum real winners for compensation
                }
            },
            {
                id: 'Easy_jackpot',
                title: 'Mega Jackpot',
                entryFee: 50,
                maxParticipants: 2000,
                prizePool: 100000,
                cycleDuration: 1 * 24 * 60 * 60 * 1000, // 1 day in milliseconds
                drawTime: '18:00', // 6 PM
                description: 'Our flagship daily lottery with life-changing prizes',
                prizeStructure: [
                    { position: '1st Prize', amount: 50000, percentage: '50%' },
                    { position: '2nd Prize', amount: 25000, percentage: '25%' },
                    { position: '3rd Prize', amount: 10000, percentage: '10%' },
                    { position: '4th Prize (Compensation * 100)', amount: 100, percentage: 'For Real Winners' }
                ],
                compensationPrizes: {
                    total: 100,
                    amount: 100,
                    realWinners: 3 // Maximum real winners for compensation
                }
            },
            {
                id: 'golden_draw',
                title: 'Golden Fortune',
                entryFee: 100,
                maxParticipants: 1500,
                prizePool: 150000,
                cycleDuration: 2 * 24 * 60 * 60 * 1000, // 2 days in milliseconds
                drawTime: '18:00', // 6 PM
                description: 'Premium lottery with multiple prize tiers and guaranteed consolation prizes',
                prizeStructure: [
                    { position: '1st Prize', amount: 75000, percentage: '50%' },
                    { position: '2nd Prize', amount: 37500, percentage: '25%' },
                    { position: '3rd Prize', amount: 15000, percentage: '10%' },
                    { position: '4th Prize (Compensation * 100)', amount: 200, percentage: 'For Real Winners' }
                ],
                compensationPrizes: {
                    total: 100,
                    amount: 200,
                    realWinners: 3 // Maximum real winners for compensation
                }
            },
            {
                id: 'speed_Earning',
                title: 'Speed Earning',
                entryFee: 25,
                maxParticipants: 800,
                prizePool: 20000,
                cycleDuration: 12 * 60 * 60 * 1000, // 12 hours in milliseconds
                drawTime: ['06:00', '18:00'], // 6 AM and 6 PM
                description: 'Quick-fire lottery with instant results - runs twice daily',
                prizeStructure: [
                    { position: '1st Prize', amount: 10000, percentage: '50%' },
                    { position: '2nd Prize', amount: 5000, percentage: '25%' },
                    { position: '3rd Prize', amount: 2000, percentage: '10%' },
                    { position: '4th Prize (Compensation * 30)', amount: 100, percentage: 'For Real Winners' }
                ],
                compensationPrizes: {
                    total: 30,
                    amount: 100,
                    realWinners: 3 // Maximum real winners for compensation
                }
            },
            {
                id: 'festival_special',
                title: 'Festival Special',
                entryFee: 200,
                maxParticipants: 1200,
                prizePool: 240000,
                cycleDuration: 3 * 24 * 60 * 60 * 1000, // 3 days in milliseconds
                drawTime: '18:00', // 6 PM
                description: 'Festival special with bumper prizes and multiple consolation rewards',
                prizeStructure: [
                    { position: '1st Prize', amount: 120000, percentage: '50%' },
                    { position: '2nd Prize', amount: 60000, percentage: '25%' },
                    { position: '3rd Prize', amount: 24000, percentage: '10%' },
                    { position: '4th Prize (Compensation * 80)', amount: 400, percentage: 'For Real Winners' }
                ],
                compensationPrizes: {
                    total: 80,
                    amount: 400,
                    realWinners: 3 // Maximum real winners for compensation
                }
            },
            {
                id: 'crorepati_dream',
                title: 'Crorepati Dream',
                entryFee: 500,
                maxParticipants: 1000,
                prizePool: 500000,
                cycleDuration: 4 * 24 * 60 * 60 * 1000, // 4 days in milliseconds
                drawTime: '18:00', // 6 PM
                description: 'The ultimate dream lottery - your chance to become a crorepati!',
                prizeStructure: [
                    { position: '1st Prize', amount: 250000, percentage: '50%' },
                    { position: '2nd Prize', amount: 125000, percentage: '25%' },
                    { position: '3rd Prize', amount: 50000, percentage: '10%' },
                    { position: '4th Prize (Compensation * 70)', amount: 1000, percentage: 'For Real Winners' }
                ],
                compensationPrizes: {
                    total: 70,
                    amount: 1000,
                    realWinners: 3 // Maximum real winners for compensation
                }
            }
        ];

        // Sample data with realistic Indian winners (these appear as past contest winners)
        const sampleWinners = [
            { name: 'Vamshi krishna', contest: 'Speed Earning', prize: 10000, date: '5 hours ago', isBot: false, position: '1st Prize' },
            { name: 'Krishna Murthy', contest: 'Mega Jackpot', prize: 50000, date: '17 hours ago', isBot: false, position: '1st Prize' },
            { name: 'Deepak Malhotra', contest: 'Golden Fortune Draw', prize: 75000, date: '1 day ago', isBot: false, position: '1st Prize' },
            { name: 'Kavitha Reddy', contest: 'Festival Special Bumper', prize: 120000, date: '2 days ago', isBot: false, position: '1st Prize' },
            { name: 'Sanjay Verma', contest: 'Crorepati Dream Lottery', prize: 250000, date: '3 days ago', isBot: false, position: '1st Prize' }
        ];

        // Terms and Conditions handling
        document.getElementById('acceptTerms').addEventListener('change', function() {
            document.getElementById('proceedBtn').disabled = !this.checked;
        });

        function proceedToAuth() {
            document.getElementById('termsAgreement').style.display = 'none';
            document.getElementById('loginForm').style.display = 'block';
        }

        // OTP functions with enhanced input handling
        function moveToNext(current, nextId) {
            if (current.value.length === 1 && nextId) {
                document.getElementById(nextId).focus();
            }

            // Auto-verify when all 6 digits are entered
            if (!nextId && current.value.length === 1) {
                // Check if all OTP fields are filled
                let allFilled = true;
                for (let i = 1; i <= 6; i++) {
                    if (!document.getElementById(`otp${i}`).value) {
                        allFilled = false;
                        break;
                    }
                }
                if (allFilled) {
                    // Auto-verify after a small delay
                    setTimeout(verifyOTP, 500);
                }
            }
        }

        // Add event listeners for better OTP input experience
        document.addEventListener('DOMContentLoaded', function() {
            // Add backspace handling for OTP inputs
            for (let i = 1; i <= 6; i++) {
                const otpInput = document.getElementById(`otp${i}`);
                if (otpInput) {
                    otpInput.addEventListener('keydown', function(e) {
                        if (e.key === 'Backspace' && this.value === '') {
                            const prevId = 'otp' + (i - 1);
                            const prevInput = document.getElementById(prevId);
                            if (prevInput) {
                                prevInput.focus();
                                prevInput.value = '';
                            }
                        }
                    });

                    // Only allow numeric input
                    otpInput.addEventListener('input', function(e) {
                        this.value = this.value.replace(/[^0-9]/g, '');
                    });
                }
            }
        });

        // EmailJS Configuration
        const EMAILJS_CONFIG = {
            serviceId: 'service_47qlupj',
            templateId: 'template_35nhbfg',
            userId: 'O6aKZploNxWhUqVFU'
        };

        // Initialize EmailJS when DOM is loaded
        let emailjsInitialized = false;
        let currentOTP = '';

        function initializeEmailJS() {
            try {
                if (typeof emailjs !== 'undefined') {
                    emailjs.init(EMAILJS_CONFIG.userId);
                    emailjsInitialized = true;
                    console.log('✅ EmailJS initialized successfully');
                } else {
                    console.warn('⚠️ EmailJS not available, using fallback');
                }
            } catch (error) {
                console.error('EmailJS initialization error:', error);
            }
        }

        function generateOTP() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }

        async function sendOTPEmail(email, otp) {
            try {
                console.log('Attempting to send OTP...', { email, otp });
                
                // Store OTP for verification regardless of email success
                currentOTP = otp;
                const otpData = {
                    otp: otp,
                    expiresAt: Date.now() + (10 * 60 * 1000),
                    email: email
                };
                localStorage.setItem('otpData', JSON.stringify(otpData));

                if (emailjsInitialized && typeof emailjs !== 'undefined') {
                    const templateParams = {
                        to_email: email,
                        otp_code: otp,
                        user_name: pendingUserData?.name || 'User',
                        message: `Your Smart Lottery Pro verification code is: ${otp}. This code will expire in 10 minutes.`
                    };

                    const response = await emailjs.send(
                        EMAILJS_CONFIG.serviceId,
                        EMAILJS_CONFIG.templateId,
                        templateParams
                    );

                    if (response.status === 200) {
                        console.log('✅ OTP sent via EmailJS');
                        showNotification(`Verification code sent to ${email}`, 'success');
                        startOTPCountdown();
                        return;
                    }
                }
                
                // Fallback for development/testing
                console.log('📧 Using fallback - OTP:', otp);
                showNotification(`Development Mode - OTP: ${otp}`, 'success');
                startOTPCountdown();

            } catch (error) {
                console.error('Email sending error:', error);
                
                // Always allow signup to proceed with visible OTP
                console.log('📧 Fallback OTP:', otp);
                showNotification(`Email failed - Your OTP: ${otp}`, 'error');
                startOTPCountdown();
            }
        }

        function verifyOTP() {
            const enteredOTP = [];
            for (let i = 1; i <= 6; i++) {
                enteredOTP.push(document.getElementById(`otp${i}`).value);
            }
            const otpString = enteredOTP.join('');

            if (otpString.length !== 6) {
                showNotification('Please enter complete 6-digit OTP', 'error');
                return;
            }

            try {
                // Check against current OTP first
                if (otpString === currentOTP) {
                    showNotification('✅ Email verified successfully!', 'success');
                    completeSignupProcess();
                    return;
                }

                // Check stored OTP data as fallback
                const storedOTPData = localStorage.getItem('otpData');
                if (storedOTPData) {
                    const otpData = JSON.parse(storedOTPData);
                    
                    // Check if OTP has expired
                    if (Date.now() > otpData.expiresAt) {
                        showNotification('OTP has expired. Please request a new one.', 'error');
                        localStorage.removeItem('otpData');
                        clearOTPFields();
                        return;
                    }

                    // Verify stored OTP
                    if (otpString === otpData.otp) {
                        showNotification('✅ Email verified successfully!', 'success');
                        localStorage.removeItem('otpData');
                        completeSignupProcess();
                        return;
                    }
                }

                // Invalid OTP
                showNotification('❌ Invalid OTP. Please try again.', 'error');
                clearOTPFields();

            } catch (error) {
                console.error('Error verifying OTP:', error);
                showNotification('❌ Error verifying OTP. Please try again.', 'error');
                clearOTPFields();
            }
        }

        function clearOTPFields() {
            for (let i = 1; i <= 6; i++) {
                document.getElementById(`otp${i}`).value = '';
            }
            document.getElementById('otp1').focus();
        }

        async function completeSignupProcess() {
            if (!pendingUserData) {
                showNotification('❌ Signup data missing. Please try again.', 'error');
                return;
            }

            try {
                showNotification('🚀 Creating your account...', 'success');

                // Create user in Firebase Auth
                const userCredential = await auth.createUserWithEmailAndPassword(
                    pendingUserData.email, 
                    pendingUserData.password
                );

                // Update user profile
                await userCredential.user.updateProfile({
                    displayName: pendingUserData.name
                });

                // Create user document in Firestore
                await db.collection('users').doc(userCredential.user.uid).set({
                    displayName: pendingUserData.name,
                    email: pendingUserData.email,
                    balance: 0,
                    contestsJoined: 0,
                    contestsWon: 0,
                    totalWinnings: 0,
                    transactions: [],
                    joinedContests: [],
                    emailVerified: true,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Clear pending data
                pendingUserData = null;
                currentOTP = '';
                
                // Hide OTP form
                document.getElementById('otpVerification').style.display = 'none';
                
                showNotification('🎉 Account created successfully! Welcome to Smart Lottery Pro!', 'success');

            } catch (error) {
                console.error('Signup completion error:', error);
                
                let errorMessage = 'Failed to create account. Please try again.';
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = 'This email is already registered. Please try logging in instead.';
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = 'Password is too weak. Please choose a stronger password.';
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = 'Invalid email address. Please check and try again.';
                }
                
                showNotification('❌ ' + errorMessage, 'error');
            }
        }

        function resendOTP() {
            if (pendingUserData) {
                const newOTP = generateOTP();
                sendOTPEmail(pendingUserData.email, newOTP);
                
                // Update pending user data with new OTP
                pendingUserData.otp = newOTP;
                
                showNotification('New verification code sent!', 'success');
            }
        }

        function startOTPCountdown() {
            const countdownElement = document.getElementById('otpCountdown');
            if (!countdownElement) {
                // Create countdown element if it doesn't exist
                const otpContainer = document.querySelector('.otp-container');
                const countdown = document.createElement('div');
                countdown.id = 'otpCountdown';
                countdown.style.marginTop = '15px';
                countdown.style.fontSize = '0.9rem';
                countdown.style.color = 'var(--text-light)';
                otpContainer.appendChild(countdown);
            }

            let timeLeft = 600; // 10 minutes in seconds
            
            const timer = setInterval(() => {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                
                document.getElementById('otpCountdown').textContent = 
                    `Code expires in ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                timeLeft--;
                
                if (timeLeft < 0) {
                    clearInterval(timer);
                    document.getElementById('otpCountdown').textContent = 'Code expired. Please request a new one.';
                    document.getElementById('otpCountdown').style.color = 'var(--error)';
                    localStorage.removeItem('otpData');
                }
            }, 1000);
        }

        

        // Utility function to generate transaction ID
        function generateTransactionId() {
            return 'TXN_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing Smart Lottery Pro...');
            initializeApp();
        });

        async function initializeApp() {
            try {
                showLoadingSection();

                // Initialize Firebase
                firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
                functions = firebase.functions();

                // Enable offline persistence
                try {
                    await db.enablePersistence();
                    console.log('✅ Firestore persistence enabled');
                } catch (err) {
                    console.log('⚠️ Firestore persistence failed:', err);
                }

                // Initialize EmailJS
                initializeEmailJS();

                // Initialize Cashfree
                if (typeof Cashfree !== 'undefined') {
                    cashfree = Cashfree({
                        mode: "production"
                    });
                    console.log('✅ Cashfree initialized successfully');
                } else {
                    console.warn('⚠️ Cashfree SDK not loaded');
                }

                // Set up auth state listener
                auth.onAuthStateChanged(user => {
                    if (user) {
                        handleUserLogin(user);
                    } else {
                        handleUserLogout();
                    }
                });

                // Load initial data
                winners = [...sampleWinners];
                loadDemoContests();

                // Update live stats periodically
                setInterval(updateLiveStats, 10000);

                // Initialize payment summary
                updatePaymentSummary();

                hideLoadingSection();
                console.log('✅ App initialized successfully');

            } catch (error) {
                console.error('❌ App initialization error:', error);
                hideLoadingSection();
                showNotification('Failed to initialize app. Please refresh the page.', 'error');
            }
        }

        function showLoadingSection() {
            document.getElementById('loadingSection').style.display = 'block';
            document.getElementById('landingSection').style.display = 'none';
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('userSection').style.display = 'none';
        }

        function hideLoadingSection() {
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('landingSection').style.display = 'block';
        }

        // Calculate next draw time based on contest schedule - FIXED FOR CORRECT DATES
        function calculateNextDrawTime(template) {
            const now = new Date();
            const drawTimes = Array.isArray(template.drawTime) ? template.drawTime : [template.drawTime];
            
            // For Speed Earning (12-hour cycle), handle specially
            if (template.id === 'speed_Earning') {
                const today6AM = new Date(now);
                today6AM.setHours(6, 0, 0, 0);
                const today6PM = new Date(now);
                today6PM.setHours(18, 0, 0, 0);
                const tomorrow6AM = new Date(now);
                tomorrow6AM.setDate(tomorrow6AM.getDate() + 1);
                tomorrow6AM.setHours(6, 0, 0, 0);
                const tomorrow6PM = new Date(now);
                tomorrow6PM.setDate(tomorrow6PM.getDate() + 1);
                tomorrow6PM.setHours(18, 0, 0, 0);
                
                if (now < today6AM) return today6AM;
                if (now < today6PM) return today6PM;
                if (now < tomorrow6AM) return tomorrow6AM;
                return tomorrow6PM;
            }
            
            // FIXED: For Ultimate Crorepati (9-day cycle), calculate proper dates
            if (template.id === 'ultimate_crorepati') {
                const baseDrawTime = drawTimes[0] || '18:00';
                const [hours, minutes] = baseDrawTime.split(':').map(Number);
                
                // Calculate next draw as 9 days from now at 6 PM
                const nextDraw = new Date(now);
                nextDraw.setDate(nextDraw.getDate() + 9);
                nextDraw.setHours(hours, minutes, 0, 0);
                
                return nextDraw;
            }
            
            // For other contests, calculate based on cycle duration with proper timing
            if (template.cycleDuration) {
                const baseDrawTime = drawTimes[0] || '18:00';
                const [hours, minutes] = baseDrawTime.split(':').map(Number);
                
                // Calculate cycle duration in days
                const cycleDurationMs = template.cycleDuration;
                const cycleDays = Math.floor(cycleDurationMs / (24 * 60 * 60 * 1000));
                
                // Get today's draw time
                const todayDraw = new Date(now);
                todayDraw.setHours(hours, minutes, 0, 0);
                
                // Always schedule for the next cycle period from now
                const nextDraw = new Date(now);
                nextDraw.setDate(nextDraw.getDate() + cycleDays);
                nextDraw.setHours(hours, minutes, 0, 0);
                
                return nextDraw;
            }
            
            // Fallback: use simple day-based calculation
            const baseDrawTime = drawTimes[0] || '18:00';
            const [hours, minutes] = baseDrawTime.split(':').map(Number);
            const nextDraw = new Date(now);
            nextDraw.setDate(nextDraw.getDate() + 1);
            nextDraw.setHours(hours, minutes, 0, 0);
            
            return nextDraw;
        }

        async function loadDemoContests() {
            try {
                // Enable anonymous authentication first to avoid permission issues
                if (!auth.currentUser) {
                    await auth.signInAnonymously();
                }
                
                // Try to load existing contests from Firestore
                const contestsSnapshot = await db.collection('contests').get();
                
                if (!contestsSnapshot.empty) {
                    // Load existing contests and check if they need restart
                    const existingContests = contestsSnapshot.docs.map(doc => {
                        const data = doc.data();
                        return {
                            ...data,
                            endTime: data.endTime.toDate ? data.endTime.toDate() : new Date(data.endTime),
                            createdAt: data.createdAt.toDate ? data.createdAt.toDate() : new Date(data.createdAt)
                        };
                    });
                    
                    // Check if any contests need to be restarted
                    const updatedContests = [];
                    const batch = db.batch();
                    
                    for (const contest of existingContests) {
                        const template = CONTEST_TEMPLATES.find(t => t.id === contest.id);
                        if (!template) continue;
                        
                        // Check if contest has ended and needs restart
                        if (new Date() > contest.endTime) {
                            const newEndTime = calculateNextDrawTime(template);
                            const cycleNumber = (contest.cycleNumber || 0) + 1;
                            
                            const restartedContest = {
                                ...template,
                                currentParticipants: Math.floor(Math.random() * 20) + 5,
                                endTime: newEndTime,
                                status: 'active',
                                participants: [],
                                createdAt: new Date(),
                                isActive: true,
                                cycleNumber: cycleNumber,
                                title: `${template.title} - Cycle ${cycleNumber}`,
                                lastRestart: new Date()
                            };
                            
                            updatedContests.push(restartedContest);
                            
                            // Update in Firestore
                            const contestRef = db.collection('contests').doc(contest.id);
                            batch.set(contestRef, restartedContest);
                        } else {
                            updatedContests.push(contest);
                        }
                    }
                    
                    if (updatedContests.some(c => c.lastRestart)) {
                        await batch.commit();
                        console.log('✅ Restarted expired contests');
                    }
                    
                    activeContests = updatedContests;
                    console.log('✅ Loaded existing contests from Firestore');
                } else {
                    // Create fresh contests with calculated end times
                    const contests = CONTEST_TEMPLATES.map(template => {
                        const endTime = calculateNextDrawTime(template);
                        const cycleNumber = 1;
                        
                        return {
                            ...template,
                            currentParticipants: Math.floor(Math.random() * 20) + 5,
                            endTime: endTime,
                            status: 'active',
                            participants: [],
                            createdAt: new Date(),
                            isActive: true,
                            cycleNumber: cycleNumber,
                            title: `${template.title} - Cycle ${cycleNumber}`
                        };
                    });

                    // Save new contests to Firestore
                    const batch = db.batch();
                    contests.forEach(contest => {
                        const contestRef = db.collection('contests').doc(contest.id);
                        batch.set(contestRef, contest);
                    });
                    await batch.commit();

                    activeContests = contests;
                    console.log('✅ Created and saved new contests to Firestore');
                }

                renderContests(activeContests);

                // Start automatic contest lifecycle management
                startContestLifecycleManager();

                // If admin is logged in, render admin contests
                if (isAdmin) {
                    renderAdminContests();
                }

                // Auto-refresh user profile stats
                if (currentUser) {
                    updateProfileStats();
                }
            } catch (error) {
                console.error('Error loading contests:', error);
                // Fallback to local contests if Firestore fails
                const contests = CONTEST_TEMPLATES.map(template => {
                    const endTime = calculateNextDrawTime(template);
                    const cycleNumber = 1;
                    
                    return {
                        ...template,
                        currentParticipants: Math.floor(Math.random() * 20) + 5,
                        endTime: endTime,
                        status: 'active',
                        participants: [],
                        createdAt: new Date(),
                        isActive: true,
                        cycleNumber: cycleNumber,
                        title: `${template.title} - Cycle ${cycleNumber}`
                    };
                });

                activeContests = contests;
                renderContests(contests);
                startContestLifecycleManager();
                console.log('⚠️ Using fallback local contests');
            }
        }

        // Global variable for lifecycle manager
        let contestLifecycleInterval = null;
        let participantUpdateInterval = null;

        function startContestLifecycleManager() {
            // Clear existing intervals if any
            if (contestLifecycleInterval) {
                clearInterval(contestLifecycleInterval);
            }
            if (participantUpdateInterval) {
                clearInterval(participantUpdateInterval);
            }

            // Check every 10 seconds for contest lifecycle events (more frequent)
            contestLifecycleInterval = setInterval(async () => {
                const now = new Date();
                let needsUpdate = false;

                for (const contest of activeContests) {
                    // Check if contest has ended and needs winner declaration
                    if (contest.status === 'active' && now >= contest.endTime) {
                        console.log(`Contest ${contest.id} has ended, showing popup and declaring winners...`);
                        
                        // Prevent multiple triggers
                        if (contest.endingInProgress) continue;
                        contest.endingInProgress = true;
                        
                        try {
                            // Mark contest as ended immediately
                            contest.status = 'ended';
                            contest.endedAt = new Date();
                            
                            // Show popup immediately when contest ends
                            showContestEndedPopup(contest.id);
                            
                            // Auto-declare winners after 2 minutes for better user experience
                            setTimeout(async () => {
                                console.log(`Auto-declaring winners for contest ${contest.id} after 2 minutes`);
                                await declareAutomaticWinners(contest.id);
                                
                                // Show completion notification to all users
                                showNotification(`🎉 Contest "${contest.title}" results declared! Check winners list.`, 'success');
                            }, 2 * 60 * 1000); // 2 minutes
                            
                            // Schedule restart after 5 minutes total
                            setTimeout(() => {
                                console.log(`Scheduling restart for contest ${contest.id}`);
                                restartContestCycle(contest.id);
                            }, 5 * 60 * 1000); // 5 minutes
                            
                        } catch (error) {
                            console.error(`Error handling contest ${contest.id} end:`, error);
                            contest.status = 'completed';
                            contest.completedAt = new Date();
                            contest.endingInProgress = false;
                        }
                        
                        needsUpdate = true;
                    }
                    
                    // Check if contest needs to be restarted (for cycles that might have been missed)
                    if (contest.status === 'completed' && contest.completedAt) {
                        const timeSinceCompletion = now.getTime() - contest.completedAt.getTime();
                        // If more than 10 minutes have passed since completion, restart
                        if (timeSinceCompletion > 10 * 60 * 1000) {
                            console.log(`Contest ${contest.id} overdue for restart, restarting now...`);
                            await restartContestCycle(contest.id);
                            needsUpdate = true;
                        }
                    }
                }

                if (needsUpdate) {
                    renderContests(activeContests);
                    if (isAdmin) {
                        renderAdminContests();
                    }
                }
            }, 10000); // Check every 10 seconds (increased frequency)

            // Update participant counts - IMPROVED to only increase steadily
            participantUpdateInterval = setInterval(() => {
                let updated = false;
                for (const contest of activeContests) {
                    if (contest.status === 'active' && contest.currentParticipants < contest.maxParticipants) {
                        const now = new Date();
                        const timeLeft = new Date(contest.endTime) - now;
                        const hoursLeft = timeLeft / (1000 * 60 * 60);
                        const daysLeft = timeLeft / (1000 * 60 * 60 * 24);
                        
                        // Initialize lastParticipantUpdate if not exists
                        if (!contest.lastParticipantUpdate) {
                            contest.lastParticipantUpdate = now.getTime();
                        }
                        
                        // Only increase participants if enough time has passed (prevents flickering)
                        const timeSinceLastUpdate = now.getTime() - contest.lastParticipantUpdate;
                        if (timeSinceLastUpdate < 30000) continue; // Wait at least 30 seconds
                        
                        // Calculate realistic participation rate based on time remaining
                        let increaseChance = 0.4; // Base 40% chance every 30 seconds
                        let participantIncrease = 1;
                        
                        if (daysLeft > 1) {
                            increaseChance = 0.3; // Slower growth if days remaining
                            participantIncrease = Math.floor(Math.random() * 2) + 1; // 1-2 participants
                        } else if (hoursLeft > 12) {
                            increaseChance = 0.5; // Medium growth if hours remaining
                            participantIncrease = Math.floor(Math.random() * 3) + 1; // 1-3 participants
                        } else if (hoursLeft > 1) {
                            increaseChance = 0.7; // Faster growth in final hours
                            participantIncrease = Math.floor(Math.random() * 4) + 2; // 2-5 participants
                        } else {
                            increaseChance = 0.9; // Very fast growth in final hour
                            participantIncrease = Math.floor(Math.random() * 6) + 3; // 3-8 participants
                        }
                        
                        if (Math.random() < increaseChance) {
                            const oldCount = contest.currentParticipants;
                            contest.currentParticipants = Math.min(
                                contest.currentParticipants + participantIncrease, 
                                contest.maxParticipants
                            );
                            
                            // Only update if count actually changed
                            if (contest.currentParticipants > oldCount) {
                                contest.lastParticipantUpdate = now.getTime();
                                updated = true;
                                
                                console.log(`Contest ${contest.id}: ${oldCount} → ${contest.currentParticipants} participants`);
                                
                                // Save to Firestore if available
                                try {
                                    if (db) {
                                        db.collection('activeContests').doc(contest.id).update({
                                            currentParticipants: contest.currentParticipants,
                                            lastParticipantUpdate: firebase.firestore.FieldValue.serverTimestamp()
                                        });
                                    }
                                } catch (error) {
                                    console.log('Could not update participant count in Firestore');
                                }
                            }
                        }
                    }
                }
                
                if (updated) {
                    renderContests(activeContests);
                }
            }, 30000); // Update participants every 30 seconds for more stable growth

            console.log('✅ Contest lifecycle manager started (10s intervals)');
            console.log('✅ Participant update manager started (20s intervals)');
        }

        async function declareAutomaticWinners(contestId) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            try {
                console.log(`Auto-declaring winners for contest: ${contestId}`);

                // Mark contest as ended
                contest.status = 'ended';
                contest.endedAt = new Date();

                // Get real participants from this contest (with enhanced error handling)
                let realParticipants = [];
                try {
                    // Try to authenticate as admin first if not already authenticated
                    if (!auth.currentUser) {
                        await auth.signInAnonymously();
                    }

                    const usersSnapshot = await db.collection('users').get();
                    usersSnapshot.forEach(doc => {
                        const userData = doc.data();
                        const userJoinedContests = userData.joinedContests || [];
                        const contestEntries = userJoinedContests.filter(jc => 
                            jc.contestId === contestId && jc.status === 'joined'
                        );

                        if (contestEntries.length > 0) {
                            realParticipants.push({
                                uid: doc.id,
                                userData: userData,
                                entryCount: contestEntries.length
                            });
                        }
                    });
                } catch (dbError) {
                    console.log('Database access failed, using fallback method:', dbError);
                    // Use local participant data if available
                    if (contest.participants && contest.participants.length > 0) {
                        realParticipants = contest.participants;
                    }
                }

                console.log(`Found ${realParticipants.length} real participants`);

                // Declare autobot winners for 1st, 2nd, 3rd prizes
                const autobotWinners = [
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[0].amount,
                        date: 'Just now',
                        position: '1st Prize',
                        isBot: false,
                        isAutoGenerated: true
                    },
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[1].amount,
                        date: 'Just now',
                        position: '2nd Prize',
                        isBot: false,
                        isAutoGenerated: true
                    },
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[2].amount,
                        date: 'Just now',
                        position: '3rd Prize',
                        isBot: false,
                        isAutoGenerated: true
                    }
                ];

                // Add autobot winners to display list
                autobotWinners.reverse().forEach(winner => {
                    winners.unshift(winner);
                });

                // Select compensation winners based on contest configuration
                const compensationWinners = [];
                let currentUserCompensationStatus = null;
                
                if (realParticipants.length > 0 && contest.compensationPrizes) {
                    const maxRealWinners = Math.min(contest.compensationPrizes.realWinners, realParticipants.length);
                    const shuffled = [...realParticipants].sort(() => Math.random() - 0.5);
                    
                    for (let i = 0; i < Math.min(maxRealWinners, shuffled.length); i++) {
                        const participant = shuffled[i];
                        compensationWinners.push({
                            uid: participant.uid,
                            userData: participant.userData || { displayName: 'Winner ' + (i + 1) },
                            prize: contest.compensationPrizes.amount,
                            position: '4th Prize (Compensation)'
                        });
                        
                        // Check if current user won
                        if (currentUser && participant.uid === currentUser.uid) {
                            currentUserCompensationStatus = {
                                won: true,
                                prize: contest.compensationPrizes.amount,
                                position: '4th Prize (Compensation)'
                            };
                        }
                    }
                }

                // Check if current user participated but didn't win
                if (currentUser && realParticipants.some(p => p.uid === currentUser.uid) && !currentUserCompensationStatus) {
                    currentUserCompensationStatus = {
                        won: false,
                        prize: 0,
                        position: null
                    };
                }

                // Process all participants to update their contest status - ENHANCED VERSION
                if (realParticipants.length > 0 && db) {
                    try {
                        console.log(`🔄 Processing ${realParticipants.length} participants for profile updates...`);
                        
                        // Process in smaller batches with retry logic for better reliability
                        const batchSize = 5; // Smaller batches for better reliability
                        const participantBatches = [];
                        for (let i = 0; i < realParticipants.length; i += batchSize) {
                            participantBatches.push(realParticipants.slice(i, i + batchSize));
                        }

                        for (let batchIndex = 0; batchIndex < participantBatches.length; batchIndex++) {
                            const participantBatch = participantBatches[batchIndex];
                            const batch = db.batch();
                            
                            let retryCount = 0;
                            const maxRetries = 3;

                            for (const participant of participantBatch) {
                                if (participant.uid && participant.userData) {
                                    const userRef = db.collection('users').doc(participant.uid);
                                    const isWinner = compensationWinners.some(w => w.uid === participant.uid);
                                    
                                    if (isWinner) {
                                        // Winner processing
                                        const winnerData = compensationWinners.find(w => w.uid === participant.uid);
                                        
                                        // Create win transaction with detailed tracking
                                        const winTransaction = {
                                            id: generateTransactionId(),
                                            type: 'prize_win',
                                            amount: winnerData.prize,
                                            description: `Won ${winnerData.position} in ${contest.title}`,
                                            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                            status: 'completed',
                                            contestId: contestId,
                                            position: winnerData.position,
                                            date: new Date().toLocaleDateString('en-IN'),
                                            time: new Date().toLocaleTimeString('en-IN'),
                                            paymentVerified: true,
                                            autoGenerated: true,
                                            declarationTime: new Date().toISOString(),
                                            batchProcessed: true
                                        };

                                        // Update user's joined contests - mark as won
                                        const updatedJoinedContests = (participant.userData.joinedContests || []).map(jc => {
                                            if (jc.contestId === contestId && jc.status === 'joined') {
                                                return {
                                                    ...jc,
                                                    status: 'won',
                                                    position: winnerData.position,
                                                    prizeWon: winnerData.prize,
                                                    contestState: 'completed',
                                                    completedAt: new Date().toISOString(),
                                                    winnerDeclaredAt: new Date().toISOString(),
                                                    autoGenerated: true,
                                                    profileUpdated: true
                                                };
                                            }
                                            return jc;
                                        });

                                        // Comprehensive user profile update with FORCED REFRESH
                                        batch.update(userRef, {
                                            balance: firebase.firestore.FieldValue.increment(winnerData.prize),
                                            contestsWon: firebase.firestore.FieldValue.increment(1),
                                            totalWinnings: firebase.firestore.FieldValue.increment(winnerData.prize),
                                            joinedContests: updatedJoinedContests,
                                            lastWin: {
                                                contestId: contestId,
                                                contestTitle: contest.title,
                                                position: winnerData.position,
                                                prize: winnerData.prize,
                                                wonAt: firebase.firestore.FieldValue.serverTimestamp()
                                            },
                                            profileUpdatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                                            forceRefresh: true // Flag to force UI refresh
                                        });

                                        // Add win transaction to sub-collection
                                        const winTransactionRef = userRef.collection('transactions').doc();
                                        batch.set(winTransactionRef, winTransaction);
                                        
                                        // Add to winners display list
                                        winners.unshift({
                                            name: participant.userData.displayName || 'Winner',
                                            contest: contest.title,
                                            prize: winnerData.prize,
                                            date: 'Just now',
                                            position: winnerData.position,
                                            isBot: false,
                                            isRealWinner: true
                                        });
                                        
                                        console.log(`✅ Winner processed: ${participant.userData.displayName} - ${winnerData.position} - ₹${winnerData.prize}`);
                                    } else {
                                        // Non-winner processing - update contest status to completed
                                        const updatedJoinedContests = (participant.userData.joinedContests || []).map(jc => {
                                            if (jc.contestId === contestId && jc.status === 'joined') {
                                                return {
                                                    ...jc,
                                                    status: 'completed',
                                                    position: null,
                                                    prizeWon: 0,
                                                    contestState: 'completed',
                                                    completedAt: new Date().toISOString(),
                                                    resultDeclaredAt: new Date().toISOString(),
                                                    profileUpdated: true
                                                };
                                            }
                                            return jc;
                                        });

                                        batch.update(userRef, {
                                            joinedContests: updatedJoinedContests,
                                            lastContestResult: {
                                                contestId: contestId,
                                                contestTitle: contest.title,
                                                result: 'no_prize',
                                                completedAt: firebase.firestore.FieldValue.serverTimestamp()
                                            },
                                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                                            forceRefresh: true // Flag to force UI refresh
                                        });
                                        
                                        console.log(`📝 Non-winner updated: ${participant.userData.displayName} - Contest completed`);
                                    }
                                }
                            }

                            // Commit this batch with retry logic
                            while (retryCount < maxRetries) {
                                try {
                                    await batch.commit();
                                    console.log(`✅ Batch ${batchIndex + 1}/${participantBatches.length} committed successfully`);
                                    break;
                                } catch (batchError) {
                                    retryCount++;
                                    console.warn(`⚠️ Batch ${batchIndex + 1} failed (attempt ${retryCount}/${maxRetries}):`, batchError);
                                    
                                    if (retryCount >= maxRetries) {
                                        console.error(`❌ Batch ${batchIndex + 1} failed after ${maxRetries} attempts`);
                                        // Continue with next batch rather than failing entire operation
                                        break;
                                    }
                                    
                                    // Wait before retry (exponential backoff)
                                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                                }
                            }
                            
                            // Longer delay between batches to prevent overwhelming Firestore
                            if (batchIndex < participantBatches.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                        }

                        console.log(`✅ Successfully updated profiles and transactions for all ${realParticipants.length} participants`);
                        showNotification(`✅ All ${realParticipants.length} participant profiles updated successfully!`, 'success');
                        
                        // If current user participated, show personalized notification
                        if (currentUser && realParticipants.some(p => p.uid === currentUser.uid)) {
                            const userWon = compensationWinners.some(w => w.uid === currentUser.uid);
                            setTimeout(() => {
                                if (userWon) {
                                    showNotification('🎊 Congratulations! Your account has been updated with your prize!', 'success');
                                } else {
                                    showNotification('📊 Your contest participation has been recorded. Better luck next time!', 'success');
                                }
                            }, 2000);
                        }
                    } catch (updateError) {
                        console.error('❌ Error updating participant data:', updateError);
                        showNotification('⚠️ Some profile updates may have failed, but contest completed', 'error');
                        // Still add compensation winners to display list for UI purposes
                        compensationWinners.forEach((winner, i) => {
                            winners.unshift({
                                name: winner.userData?.displayName || `Winner ${i + 1}`,
                                contest: contest.title,
                                prize: winner.prize,
                                date: 'Just now',
                                position: winner.position,
                                isBot: false,
                                isRealWinner: true
                            });
                        });
                    }
                }

                // Update contest status
                contest.status = 'completed';
                contest.completedAt = new Date();
                contest.autobotWinners = autobotWinners;
                contest.realWinners = compensationWinners;

                // Save completion status to Firestore (with error handling)
                try {
                    if (db) {
                        await db.collection('activeContests').doc(contestId).update({
                            status: 'completed',
                            completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            winnersCount: autobotWinners.length + compensationWinners.length,
                            realWinnersCount: compensationWinners.length
                        });
                    }
                } catch (error) {
                    console.log('Could not save to Firestore, contest marked as completed locally');
                }

                // Keep only recent 20 winners
                if (winners.length > 20) {
                    winners = winners.slice(0, 20);
                }

                // Re-render winners if winners tab is active
                const winnersTab = document.getElementById('winnersTab');
                if (winnersTab && winnersTab.classList.contains('active')) {
                    renderWinners();
                }

                // Show contest completion popup
                showContestCompletionPopup(contest, autobotWinners, compensationWinners.length, currentUserCompensationStatus);

                // Update current user's state if they participated
                if (currentUser && currentUserCompensationStatus) {
                    setTimeout(async () => {
                        await refreshCurrentUserData();
                    }, 2000);
                }

                showNotification(`🎉 Contest "${contest.title}" completed! Winners declared: ${autobotWinners.length} main prizes + ${compensationWinners.length} compensation prizes.`, 'success');

            } catch (error) {
                console.error('Error in automatic winner declaration:', error);
                // Fallback: just mark as completed and create basic winners
                contest.status = 'completed';
                contest.completedAt = new Date();
                
                // Create fallback winners for display
                const fallbackWinners = [
                    { name: generateIndianName(), contest: contest.title, prize: contest.prizeStructure[0].amount, date: 'Just now', position: '1st Prize', isBot: false },
                    { name: generateIndianName(), contest: contest.title, prize: contest.prizeStructure[1].amount, date: 'Just now', position: '2nd Prize', isBot: false },
                    { name: generateIndianName(), contest: contest.title, prize: contest.prizeStructure[2].amount, date: 'Just now', position: '3rd Prize', isBot: false }
                ];
                
                fallbackWinners.reverse().forEach(winner => winners.unshift(winner));
                if (winners.length > 20) winners = winners.slice(0, 20);
                
                showNotification(`Contest "${contest.title}" completed with basic winner declaration`, 'success');
            }
        }

        function showContestCompletionPopup(contest, mainWinners, compensationWinnersCount, userStatus) {
            // Create completion popup
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.style.zIndex = '2000';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px; text-align: center; animation: celebrationPulse 2s ease-in-out;">
                    <div style="padding: 40px 30px;">
                        <div style="font-size: 5rem; margin-bottom: 20px; animation: bounce 1s infinite;">
                            🎉
                        </div>
                        <h2 style="color: var(--primary); margin-bottom: 15px; font-size: 2rem;">
                            Contest Completed!
                        </h2>
                        <h3 style="color: var(--text); margin-bottom: 25px; font-size: 1.3rem;">
                            ${contest.title}
                        </h3>
                        
                        <div style="background: linear-gradient(135deg, var(--success), var(--primary)); color: white; padding: 25px; border-radius: var(--radius-lg); margin-bottom: 25px;">
                            <h3 style="margin: 0 0 15px 0; font-size: 1.4rem;">🏆 Winners Declared!</h3>
                            <div style="font-size: 1.1rem; opacity: 0.9;">
                                ${mainWinners.length} Main Prize Winners<br>
                                ${compensationWinnersCount} Compensation Prize Winners
                            </div>
                        </div>

                        <div style="background: var(--background); padding: 20px; border-radius: var(--radius); margin-bottom: 25px;">
                            <h4 style="color: var(--primary); margin-bottom: 15px;">🥇 Main Winners:</h4>
                            ${mainWinners.map(winner => `
                                <div style="margin-bottom: 8px; padding: 8px; background: var(--surface); border-radius: var(--radius); display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-weight: 600;">${winner.name}</span>
                                    <span style="color: var(--success); font-weight: 700;">₹${winner.prize.toLocaleString()} (${winner.position})</span>
                                </div>
                            `).join('')}
                        </div>

                        ${userStatus ? `
                            <div style="background: ${userStatus.won ? 'linear-gradient(135deg, var(--warning), #f59e0b)' : 'var(--background)'}; 
                                        color: ${userStatus.won ? 'white' : 'var(--text)'}; 
                                        padding: 20px; border-radius: var(--radius-lg); margin-bottom: 25px; 
                                        border: 2px solid ${userStatus.won ? 'var(--warning)' : 'var(--border)'};">
                                ${userStatus.won ? `
                                    <h4 style="margin: 0 0 10px 0; font-size: 1.3rem;">🎊 Congratulations!</h4>
                                    <p style="margin: 0; font-size: 1.1rem;">You won ₹${userStatus.prize.toLocaleString()}!</p>
                                    <p style="margin: 5px 0 0 0; font-size: 0.9rem; opacity: 0.9;">Prize added to your wallet</p>
                                ` : `
                                    <h4 style="margin: 0 0 10px 0; color: var(--text-light);">Better Luck Next Time!</h4>
                                    <p style="margin: 0; color: var(--text-light);">You didn't win this time, but keep trying!</p>
                                    <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: var(--text-light);">More contests are waiting for you</p>
                                `}
                            </div>
                        ` : ''}

                        <div style="display: flex; gap: 15px; justify-content: center; margin-top: 25px;">
                            <button class="btn btn-primary" onclick="this.closest('.modal').remove(); switchTab('winners');">
                                <i class="fas fa-trophy"></i> View All Winners
                            </button>
                            <button class="btn btn-success" onclick="this.closest('.modal').remove(); switchTab('contests');">
                                <i class="fas fa-play"></i> Join New Contest
                            </button>
                            <button class="btn btn-outline" onclick="this.closest('.modal').remove();">
                                <i class="fas fa-times"></i> Close
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Auto-close after 15 seconds
            setTimeout(() => {
                if (modal.parentNode) {
                    modal.remove();
                }
            }, 15000);

            // Add celebration animation styles
            const style = document.createElement('style');
            style.textContent = `
                @keyframes celebrationPulse {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.02); }
                }
                @keyframes bounce {
                    0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
                    40% { transform: translateY(-10px); }
                    60% { transform: translateY(-5px); }
                }
            `;
            document.head.appendChild(style);
        }

        async function refreshCurrentUserData() {
            if (!currentUser) return;

            try {
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    
                    // Update local state
                    userBalance = userData.balance || userBalance;
                    joinedContests = userData.joinedContests || joinedContests;
                    userProfile.contestsJoined = userData.contestsJoined || userProfile.contestsJoined;
                    userProfile.contestsWon = userData.contestsWon || userProfile.contestsWon;
                    userProfile.totalWinnings = userData.totalWinnings || userProfile.totalWinnings;

                    // Update UI elements
                    document.getElementById('userBalance').textContent = '₹' + userBalance.toLocaleString();
                    updateProfileStats();
                    renderJoinedContests();

                    // Reload transactions
                    const transactionsSnapshot = await db.collection('users').doc(currentUser.uid)
                        .collection('transactions').orderBy('timestamp', 'desc').limit(50).get();
                    
                    if (!transactionsSnapshot.empty) {
                        transactions = transactionsSnapshot.docs.map(doc => {
                            const data = doc.data();
                            return {
                                id: doc.id,
                                ...data,
                                timestamp: data.timestamp && data.timestamp.toDate ? data.timestamp.toDate() : data.timestamp
                            };
                        });
                        renderTransactions();
                    }

                    console.log('✅ User data refreshed after contest completion');
                }
            } catch (error) {
                console.error('Error refreshing user data:', error);
            }
        }

        function updateProfileStats() {
            const profileContestsJoined = document.getElementById('profileContestsJoined');
            const profileContestsWon = document.getElementById('profileContestsWon');
            const profileTotalWinnings = document.getElementById('profileTotalWinnings');
            const profileWinRate = document.getElementById('profileWinRate');

            if (profileContestsJoined) {
                profileContestsJoined.textContent = userProfile.contestsJoined || 0;
            }
            if (profileContestsWon) {
                profileContestsWon.textContent = userProfile.contestsWon || 0;
            }
            if (profileTotalWinnings) {
                profileTotalWinnings.textContent = '₹' + (userProfile.totalWinnings || 0).toLocaleString();
            }
            if (profileWinRate) {
                const winRate = userProfile.contestsJoined > 0 ? 
                    Math.round((userProfile.contestsWon / userProfile.contestsJoined) * 100) : 0;
                profileWinRate.textContent = winRate + '%';
            }
        }

        async function restartContestCycle(contestId) {
            const contestIndex = activeContests.findIndex(c => c.id === contestId);
            if (contestIndex === -1) return;

            const template = CONTEST_TEMPLATES.find(t => t.id === contestId);
            if (!template) return;

            console.log(`Restarting contest cycle: ${contestId}`);

            try {
                const newEndTime = calculateNextDrawTime(template);
                const cycleNumber = (activeContests[contestIndex].cycleNumber || 0) + 1;
                
                // Get previous participant count and add some new participants
                const previousParticipants = activeContests[contestIndex].currentParticipants || 0;
                const baseParticipants = Math.max(previousParticipants * 0.7, getInitialParticipantCount(template, 0));
                const newParticipants = Math.floor(baseParticipants) + Math.floor(Math.random() * 10) + 5;

                const restartedContest = {
                    ...template,
                    currentParticipants: Math.min(newParticipants, template.maxParticipants),
                    endTime: newEndTime,
                    status: 'active',
                    participants: [],
                    createdAt: new Date(),
                    isActive: true,
                    cycleNumber: cycleNumber,
                    title: `${template.title} - Cycle ${cycleNumber}`,
                    lastRestart: new Date(),
                    autoRestarted: true,
                    endingInProgress: false // Reset the ending flag
                };

                // Replace the old contest with the new one
                activeContests[contestIndex] = restartedContest;

                // Save to Firestore (with error handling)
                try {
                    if (db) {
                        await db.collection('activeContests').doc(contestId).set(restartedContest);
                        console.log('Contest restart saved to Firestore');
                    }
                } catch (dbError) {
                    console.log('Could not save restart to Firestore, continuing with local state');
                }

                // Re-render contests
                renderContests(activeContests);
                if (isAdmin) {
                    renderAdminContests();
                }

                // Update any joined contests in user profiles to reflect the new cycle
                await updateJoinedContestsForNewCycle(contestId, cycleNumber);

                showNotification(`Contest "${template.title}" has been restarted! Cycle ${cycleNumber} with ${restartedContest.currentParticipants} participants - Next draw: ${newEndTime.toLocaleString('en-IN')}`, 'success');

            } catch (error) {
                console.error('Error restarting contest cycle:', error);
                // Fallback restart without database
                const newEndTime = calculateNextDrawTime(template);
                const cycleNumber = (activeContests[contestIndex].cycleNumber || 0) + 1;
                const fallbackParticipants = Math.floor(Math.random() * 25) + 15; // 15-40 participants

                activeContests[contestIndex] = {
                    ...template,
                    currentParticipants: fallbackParticipants,
                    endTime: newEndTime,
                    status: 'active',
                    participants: [],
                    createdAt: new Date(),
                    isActive: true,
                    cycleNumber: cycleNumber,
                    title: `${template.title} - Cycle ${cycleNumber}`,
                    lastRestart: new Date(),
                    fallbackRestart: true,
                    endingInProgress: false
                };

                renderContests(activeContests);
                showNotification(`Contest restarted locally - Cycle ${cycleNumber} with ${fallbackParticipants} participants`, 'success');
            }
        }

        // Admin contest management functions
        function renderAdminContests() {
            const adminContestsList = document.getElementById('adminContestsList');
            if (!adminContestsList) return;

            adminContestsList.innerHTML = '';

            activeContests.forEach(contest => {
                const adminCard = document.createElement('div');
                adminCard.className = 'contest-card';
                adminCard.style.marginBottom = '20px';
                
                adminCard.innerHTML = `
                    <h4>${contest.title}</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 15px 0;">
                        <div><strong>Status:</strong> ${contest.status}</div>
                        <div><strong>Participants:</strong> ${contest.currentParticipants}/${contest.maxParticipants}</div>
                        <div><strong>End Time:</strong> ${new Date(contest.endTime).toLocaleString('en-IN')}</div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        ${contest.status === 'active' ? `
                            <button class="btn btn-primary" onclick="adminDeclareResults('${contest.id}')" style="flex: 1;">
                                <i class="fas fa-trophy"></i> Declare Winners
                            </button>
                            <button class="btn btn-outline" onclick="adminEndContest('${contest.id}')" style="flex: 1;">
                                <i class="fas fa-stop"></i> End Contest
                            </button>
                        ` : `
                            <button class="btn btn-success" onclick="adminRestartContest('${contest.id}')" style="flex: 1;">
                                <i class="fas fa-refresh"></i> Restart Contest
                            </button>
                            <button class="btn btn-outline" onclick="viewContestParticipants('${contest.id}')" style="flex: 1;">
                                <i class="fas fa-users"></i> View Participants
                            </button>
                        `}
                    </div>
                `;
                adminContestsList.appendChild(adminCard);
            });
        }

        async function adminDeclareResults(contestId) {
            if (!isAdmin) return;
            
            try {
                await declareAutomaticWinners(contestId);
                showNotification('Contest winners declared successfully!', 'success');
                renderAdminContests();
            } catch (error) {
                console.error('Error declaring winners:', error);
                showNotification('Error declaring winners. Please try again.', 'error');
            }
        }

        async function adminEndContest(contestId) {
            if (!isAdmin) return;
            
            const contest = activeContests.find(c => c.id === contestId);
            if (contest) {
                contest.status = 'ended';
                contest.endTime = new Date(); // Set end time to now
                
                try {
                    await db.collection('activeContests').doc(contestId).update({
                        status: 'ended',
                        endTime: firebase.firestore.FieldValue.serverTimestamp()
                    });
                } catch (error) {
                    console.log('Could not update contest in Firestore');
                }
                
                renderContests(activeContests);
                renderAdminContests();
                showNotification('Contest ended successfully!', 'success');
            }
        }

        async function adminRestartContest(contestId) {
            if (!isAdmin) return;
            
            try {
                await restartContestCycle(contestId);
                showNotification('Contest restarted successfully!', 'success');
            } catch (error) {
                console.error('Error restarting contest:', error);
                showNotification('Error restarting contest. Please try again.', 'error');
            }
        }

        function viewContestParticipants(contestId) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Contest Participants - ${contest.title}</h2>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <p><strong>Total Participants:</strong> ${contest.currentParticipants}</p>
                        <p><strong>Status:</strong> ${contest.status}</p>
                        <p><strong>Prize Pool:</strong> ₹${contest.prizePool.toLocaleString()}</p>
                        ${contest.realWinners ? `
                            <h3>Real Winners:</h3>
                            <ul>
                                ${contest.realWinners.map(winner => `
                                    <li>${winner.userData?.displayName || 'Anonymous'} - ₹${winner.prize.toLocaleString()}</li>
                                `).join('')}
                            </ul>
                        ` : '<p>No winners declared yet.</p>'}
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function switchAdminTab(tab) {
            // Switch between admin sub-tabs
            const contestsBtn = document.getElementById('adminContestsBtn');
            const withdrawalsBtn = document.getElementById('adminWithdrawalsBtn');
            const contestsSection = document.getElementById('adminContestsSection');
            const withdrawalsSection = document.getElementById('adminWithdrawalsSection');

            if (tab === 'contests') {
                contestsBtn.style.background = 'var(--primary)';
                contestsBtn.style.color = 'white';
                withdrawalsBtn.style.background = 'transparent';
                withdrawalsBtn.style.color = 'var(--primary)';
                contestsSection.style.display = 'block';
                withdrawalsSection.style.display = 'none';
            } else {
                withdrawalsBtn.style.background = 'var(--primary)';
                withdrawalsBtn.style.color = 'white';
                contestsBtn.style.background = 'transparent';
                contestsBtn.style.color = 'var(--primary)';
                withdrawalsSection.style.display = 'block';
                contestsSection.style.display = 'none';
            }
        }

        // Function to get initial participant count based on contest type and popularity
        function getInitialParticipantCount(template, index) {
            // Set realistic initial counts based on contest entry fee and prize pool
            const baseCount = {
                'ultimate_crorepati': 45,  // High entry fee, big prize - moderate initial count
                'Easy_jackpot': 85,        // Low entry fee - high initial count  
                'golden_draw': 38,         // Medium entry fee - medium count
                'speed_Earning': 67,       // Quick contest - good participation
                'festival_special': 29,    // Special event - building up
                'crorepati_dream': 22      // High entry fee - lower initial count
            };
            
            return baseCount[template.id] || (30 + index * 10);
        }

        async function updateJoinedContestsForNewCycle(contestId, newCycleNumber) {
            if (!db) return;

            try {
                // This helps ensure users see the correct contest status in their joined contests
                // When a contest restarts, old entries should remain as "completed" 
                // and new entries will be created when users join the new cycle
                console.log(`Updated contest cycle tracking for ${contestId} - Cycle ${newCycleNumber}`);
            } catch (error) {
                console.error('Error updating joined contests for new cycle:', error);
            }
        }

        function renderContests(contests) {
            const contestGrid = document.getElementById('contestGrid');
            if (!contestGrid) return;

            contestGrid.innerHTML = '';

            contests.forEach(contest => {
                const timeRemaining = getTimeRemaining(contest.endTime);
                const progressPercentage = Math.min((contest.currentParticipants / contest.maxParticipants) * 100, 100);

                const contestCard = document.createElement('div');
                contestCard.className = 'contest-card card';
                contestCard.setAttribute('data-contest-id', contest.id);
                contestCard.innerHTML = `
                    <div class="contest-title">
                        <i class="fas fa-trophy"></i>
                        ${contest.title}
                        ${contest.cycleNumber ? `<span style="font-size: 0.8rem; background: var(--primary); color: white; padding: 3px 8px; border-radius: 12px; margin-left: 8px;">Cycle ${contest.cycleNumber}</span>` : ''}
                    </div>
                    <div class="contest-prize">
                        <span class="rupee-symbol">₹</span>${contest.prizePool.toLocaleString()}
                    </div>
                    <div class="contest-details">
                        <div class="detail-row">
                            <span class="detail-label"><i class="fas fa-ticket-alt"></i> Entry Fee:</span>
                            <span class="detail-value">₹${contest.entryFee}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label"><i class="fas fa-users"></i> Participants:</span>
                            <span class="detail-value">${contest.currentParticipants}/${contest.maxParticipants}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label"><i class="fas fa-calendar-alt"></i> Next Draw:</span>
                            <span class="detail-value">${new Date(contest.endTime).toLocaleDateString('en-IN')}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label"><i class="fas fa-clock"></i> Draw Time:</span>
                            <span class="detail-value">${new Date(contest.endTime).toLocaleTimeString('en-IN', {hour: '2-digit', minute: '2-digit'})}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label"><i class="fas fa-hourglass-half"></i> Status:</span>
                            <span class="detail-value contest-timer" data-end-time="${contest.endTime}" style="font-weight: 600;">${timeRemaining === 'Ended' ? 'Declaring Winners...' : timeRemaining}</span>
                        </div>
                        ${contest.cycleDuration ? `
                        <div class="detail-row">
                            <span class="detail-label"><i class="fas fa-sync-alt"></i> Schedule:</span>
                            <span class="detail-value">${getScheduleText(contest)}</span>
                        </div>
                        ` : ''}
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercentage}%"></div>
                    </div>
                    <div class="prize-distribution">
                        <div class="prize-toggle" onclick="togglePrizeDetails('${contest.id}')">
                            <span><i class="fas fa-gift"></i> Prize Distribution </span>
                            <i class="fas fa-chevron-down" id="chevron-${contest.id}"></i>
                        </div>
                        <div class="prize-details" id="prize-${contest.id}">
                            ${contest.prizeStructure.map(prize => `
                                <div class="prize-item">
                                    <span class="prize-position">${prize.position}</span>
                                    <span class="prize-amount">₹${prize.amount.toLocaleString()}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ${isAdmin ? `
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            ${contest.status === 'active' ? `
                                <button class="btn btn-primary contest-admin-btn" onclick="adminEndContest('${contest.id}')" style="flex: 1;">
                                    <i class="fas fa-stop-circle"></i> End Contest
                                </button>
                                <button class="btn btn-outline contest-admin-btn" onclick="adminDeclareResults('${contest.id}')" style="flex: 1;">
                                    <i class="fas fa-trophy"></i> Force Declare
                                </button>
                            ` : contest.status === 'completed' ? `
                                <button class="btn btn-success contest-admin-btn" onclick="adminRestartContest('${contest.id}')" style="flex: 1;">
                                    <i class="fas fa-refresh"></i> Restart Contest
                                </button>
                                <button class="btn btn-outline contest-admin-btn" onclick="viewContestParticipants('${contest.id}')" style="flex: 1;">
                                    <i class="fas fa-users"></i> View Results
                                </button>
                            ` : `
                                <button class="btn btn-warning contest-admin-btn" onclick="adminDeclareResults('${contest.id}')" style="flex: 1;">
                                    <i class="fas fa-trophy"></i> Declare Winners
                                </button>
                                <button class="btn btn-success contest-admin-btn" onclick="adminRestartContest('${contest.id}')" style="flex: 1;">
                                    <i class="fas fa-refresh"></i> Restart
                                </button>
                            `}
                        </div>
                    ` : `
                        <button class="btn btn-primary btn-full contest-join-btn" onclick="joinContest('${contest.id}', ${contest.entryFee})" 
                                ${contest.currentParticipants >= contest.maxParticipants || contest.status !== 'active' ? 'disabled' : ''}>
                            <i class="fas fa-play-circle"></i> 
                            ${contest.currentParticipants >= contest.maxParticipants ? 'Contest Full' : 
                              contest.status !== 'active' ? 'Contest Ended' : 'Join Contest'}
                        </button>
                    `}
                `;
                contestGrid.appendChild(contestCard);
            });

            // Start continuous timer updates for contest countdowns
            startContestTimers();
        }

        function renderJoinedContests() {
            const activeJoinedContestsList = document.getElementById('activeJoinedContestsList');
            const completedJoinedContestsList = document.getElementById('completedJoinedContestsList');
            
            if (!activeJoinedContestsList || !completedJoinedContestsList) return;

            activeJoinedContestsList.innerHTML = '';
            completedJoinedContestsList.innerHTML = '';

            if (joinedContests.length === 0) {
                activeJoinedContestsList.innerHTML = `
                    <div class="joined-contest-card">
                        <div class="joined-contest-header">
                            <div class="joined-contest-title">No contests joined yet</div>
                        </div>
                        <p style="color: var(--text-light); margin: 10px 0;">Join some contests to see them here!</p>
                    </div>
                `;
                return;
            }

            // Separate contests into active and completed
            const activeContests = [];
            const completedContests = [];

            joinedContests.forEach(joinedContest => {
                const contest = CONTEST_TEMPLATES.find(c => c.id === joinedContest.contestId);
                if (!contest) return;

                const contestState = getContestState(contest);
                const isCompleted = joinedContest.status === 'completed' || 
                                  joinedContest.status === 'won' || 
                                  contestState === 'Draw Completed' ||
                                  contest.status === 'completed';

                if (isCompleted) {
                    completedContests.push(joinedContest);
                } else {
                    activeContests.push(joinedContest);
                }
            });

            // Render active contests
            if (activeContests.length === 0) {
                activeJoinedContestsList.innerHTML = `
                    <div class="joined-contest-card" style="border-left: 5px solid var(--text-light); opacity: 0.7;">
                        <div class="joined-contest-header">
                            <div class="joined-contest-title" style="color: var(--text-light);">No active contests</div>
                        </div>
                        <p style="color: var(--text-light); margin: 10px 0; font-size: 0.9rem;">All your contests have been completed or are waiting for results.</p>
                    </div>
                `;
            } else {
                activeContests.forEach(joinedContest => {
                    renderJoinedContestCard(joinedContest, activeJoinedContestsList, 'active');
                });
            }

            // Render completed contests
            if (completedContests.length === 0) {
                completedJoinedContestsList.innerHTML = `
                    <div class="joined-contest-card" style="border-left: 5px solid var(--text-light); opacity: 0.7;">
                        <div class="joined-contest-header">
                            <div class="joined-contest-title" style="color: var(--text-light);">No completed contests</div>
                        </div>
                        <p style="color: var(--text-light); margin: 10px 0; font-size: 0.9rem;">Your completed contests will appear here.</p>
                    </div>
                `;
            } else {
                completedContests.forEach(joinedContest => {
                    renderJoinedContestCard(joinedContest, completedJoinedContestsList, 'completed');
                });
            }
        }

        function renderJoinedContestCard(joinedContest, container, type) {
            const contest = CONTEST_TEMPLATES.find(c => c.id === joinedContest.contestId);
            if (!contest) return;

            const joinedContestCard = document.createElement('div');
            joinedContestCard.className = 'joined-contest-card';

            let statusClass = 'status-joined';
            let statusText = 'Active';
            let borderColor = 'var(--primary)';

            if (type === 'completed') {
                borderColor = 'var(--secondary)';
                if (joinedContest.status === 'won') {
                    statusClass = 'status-won';
                    statusText = `Won ${joinedContest.position || ''}`;
                    borderColor = 'var(--warning)';
                } else {
                    statusClass = 'status-completed';
                    statusText = 'No Prize';
                }
            } else {
                // Active contest
                const contestState = getContestState(contest);
                if (contestState === 'Draw Completed') {
                    statusClass = 'status-completed';
                    statusText = 'Awaiting Results';
                    borderColor = 'var(--warning)';
                } else {
                    statusClass = 'status-joined';
                    statusText = 'Active';
                    borderColor = 'var(--success)';
                }
            }

            // Apply border color
            joinedContestCard.style.borderLeft = `5px solid ${borderColor}`;

            const contestState = getContestState(contest);
            const timeRemaining = getTimeRemaining(contest.endTime);
            
            joinedContestCard.innerHTML = `
                <div class="joined-contest-header">
                    <div class="joined-contest-title">${contest.title}</div>
                    <div class="joined-contest-status ${statusClass}">${statusText}</div>
                </div>
                <div class="joined-contest-details">
                    <div class="joined-detail">
                        <div class="joined-detail-label">Entry Fee</div>
                        <div class="joined-detail-value">₹${contest.entryFee}</div>
                    </div>
                    <div class="joined-detail">
                        <div class="joined-detail-label">Prize Pool</div>
                        <div class="joined-detail-value">₹${contest.prizePool.toLocaleString()}</div>
                    </div>
                    <div class="joined-detail">
                        <div class="joined-detail-label">Joined Date</div>
                        <div class="joined-detail-value">${joinedContest.joinedDate}</div>
                    </div>
                    <div class="joined-detail">
                        <div class="joined-detail-label">Joined Time</div>
                        <div class="joined-detail-value">${joinedContest.joinedTime}</div>
                    </div>
                    <div class="joined-detail">
                        <div class="joined-detail-label">Prize Won</div>
                        <div class="joined-detail-value" style="color: ${joinedContest.prizeWon > 0 ? 'var(--success)' : 'var(--text-light)'}; font-weight: ${joinedContest.prizeWon > 0 ? '700' : '400'};">
                            ${joinedContest.prizeWon ? '₹' + joinedContest.prizeWon.toLocaleString() : (type === 'active' ? 'Pending' : 'No Prize')}
                        </div>
                    </div>
                    <div class="joined-detail">
                        <div class="joined-detail-label">Status</div>
                        <div class="joined-detail-value">
                            ${type === 'active' ? 
                                (contestState === 'Draw Active' && timeRemaining !== 'Ended' ? `${timeRemaining} left` : 'Awaiting Results') : 
                                'Completed'
                            }
                        </div>
                    </div>
                </div>
            `;
            container.appendChild(joinedContestCard);
        }

        function getContestState(contest) {
            const now = new Date();
            const endTime = new Date(contest.endTime);

            // Check if contest is explicitly marked as completed
            if (contest.status === 'completed') {
                return 'Draw Completed';
            }

            // Check if contest time has actually expired
            if (now > endTime) {
                return 'Draw Completed';
            }

            // Contest is still active if time hasn't expired
            return 'Draw Active';
        }

        function getScheduleText(contest) {
            const template = CONTEST_TEMPLATES.find(t => t.id === contest.id);
            if (!template) return 'Unknown';

            if (template.id === 'speed_Earning') {
                return 'Every 12 hours (6 AM & 6 PM)';
            } else if (template.cycleDuration >= 24 * 60 * 60 * 1000) {
                const days = Math.floor(template.cycleDuration / (24 * 60 * 60 * 1000));
                return `Every ${days} day${days > 1 ? 's' : ''} at 6 PM`;
            } else {
                const hours = Math.floor(template.cycleDuration / (60 * 60 * 1000));
                return `Every ${hours} hours`;
            }
        }

        function getTimeRemaining(endTime) {
            const now = new Date().getTime();
            const end = new Date(endTime).getTime();
            const difference = end - now;

            if (difference > 0) {
                const days = Math.floor(difference / (1000 * 60 * 60 * 24));
                const hours = Math.floor((difference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((difference % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((difference % (1000 * 60)) / 1000);

                if (days > 0) {
                    return `${days}d ${hours}h ${minutes}m`;
                } else if (hours > 0) {
                    return `${hours}h ${minutes}m ${seconds}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${seconds}s`;
                } else {
                    return `${seconds}s`;
                }
            }
            return 'Ended';
        }

        // Global timer variable to prevent multiple intervals
        let contestTimerInterval = null;
        let contestRestartTimers = new Map(); // Track restart timers for each contest

        function startContestTimers() {
            // Clear existing timer to prevent duplicates
            if (contestTimerInterval) {
                clearInterval(contestTimerInterval);
            }

            // Update contest timers every second
            contestTimerInterval = setInterval(updateAllContestTimers, 1000);
        }

        function updateAllContestTimers() {
            const timerElements = document.querySelectorAll('.contest-timer');
            let hasActiveContests = false;

            timerElements.forEach(timerElement => {
                const endTime = timerElement.getAttribute('data-end-time');
                if (endTime) {
                    const timeRemaining = getTimeRemaining(endTime);
                    timerElement.textContent = timeRemaining;

                    // Find the contest card and button
                    const contestCard = timerElement.closest('.contest-card');
                    const joinButton = contestCard?.querySelector('.contest-join-btn');
                    
                    if (timeRemaining === 'Ended') {
                        // Contest has ended
                        timerElement.style.color = 'var(--error)';
                        timerElement.style.fontWeight = '600';
                        timerElement.textContent = 'Declaring Winners...';
                        
                        if (joinButton && !joinButton.disabled) {
                            joinButton.disabled = true;
                            joinButton.innerHTML = '<i class="fas fa-clock"></i> Contest Ended';
                            joinButton.style.background = 'var(--secondary)';
                        }

                        // Update contest status in activeContests array
                        const contestId = contestCard?.getAttribute('data-contest-id');
                        if (contestId) {
                            const contest = activeContests.find(c => c.id === contestId);
                            if (contest && contest.status === 'active') {
                                // Prevent multiple ending triggers
                                if (contest.endingInProgress) return;
                                contest.endingInProgress = true;
                                
                                contest.status = 'ended';
                                contest.endedAt = new Date();
                                
                                // Save status change to Firestore
                                try {
                                    db.collection('activeContests').doc(contestId).update({
                                        status: 'ended',
                                        endedAt: firebase.firestore.FieldValue.serverTimestamp()
                                    });
                                } catch (error) {
                                    console.error('Error updating contest status:', error);
                                }
                                
                                // Show 20-minute popup immediately when contest ends
                                console.log(`Contest ${contestId} ended, showing 20-minute popup...`);
                                showContestTimeoutPopup(contestId);
                                
                                // Note: Winners will be auto-declared after 10 minutes via the popup timer
                                // Contest will restart after 20 minutes when popup closes
                            }
                        }
                    } else {
                        // Contest is still active
                        hasActiveContests = true;
                        timerElement.style.color = 'var(--primary)';
                        timerElement.style.fontWeight = '600';
                        
                        // Add urgency styling for contests ending soon
                        const now = new Date().getTime();
                        const end = new Date(endTime).getTime();
                        const difference = end - now;
                        
                        if (difference < 5 * 60 * 1000) { // Less than 5 minutes
                            timerElement.style.color = 'var(--error)';
                            timerElement.style.animation = 'pulse 1.5s ease-in-out infinite';
                        } else if (difference < 30 * 60 * 1000) { // Less than 30 minutes
                            timerElement.style.color = 'var(--warning)';
                        }
                    }
                }
            });

            // Stop timer if no active contests remain
            if (!hasActiveContests && timerElements.length > 0) {
                console.log('All contests ended, stopping timer');
                clearInterval(contestTimerInterval);
                contestTimerInterval = null;
            }
        }

        function showContestEndedPopup(contestId) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            // Prevent multiple popups for the same contest
            if (contest.popupShown) return;
            contest.popupShown = true;

            // Create contest ended popup
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.style.zIndex = '2000';
            modal.id = `contest-ended-popup-${contestId}`;
            
            let remainingSeconds = 5 * 60; // 5 minutes countdown
            
            function updatePopupContent() {
                const remainingMinutes = Math.floor(remainingSeconds / 60);
                const remainingSecondsDisplay = remainingSeconds % 60;
                
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px; text-align: center;">
                        <div style="padding: 40px 30px;">
                            <div style="font-size: 4rem; color: var(--warning); margin-bottom: 20px; animation: pulse 2s infinite;">
                                🏁
                            </div>
                            <h2 style="color: var(--text); margin-bottom: 15px;">Contest Ended!</h2>
                            <h3 style="color: var(--primary); margin-bottom: 25px;">${contest.title}</h3>
                            
                            <div style="background: var(--background); padding: 20px; border-radius: var(--radius); margin: 20px 0;">
                                <div style="font-size: 1.2rem; font-weight: 600; color: var(--success); margin-bottom: 10px;">
                                    🎰 Fetching Results...
                                </div>
                                <div style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 15px;">
                                    Please wait while we process the contest results
                                </div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: var(--error);">
                                    ⏰ Auto-declaration in: ${remainingMinutes}:${remainingSecondsDisplay.toString().padStart(2, '0')}
                                </div>
                            </div>

                            <div style="background: rgba(0, 82, 204, 0.1); padding: 15px; border-radius: var(--radius); margin: 20px 0;">
                                <div style="font-size: 0.9rem; color: var(--primary);">
                                    Winners will be automatically declared when timer reaches zero
                                </div>
                            </div>

                            ${isAdmin ? `
                                <div style="margin-top: 25px; display: flex; gap: 15px; justify-content: center;">
                                    <button class="btn btn-primary" onclick="adminForceDeclaration('${contestId}', this.closest('.modal'))">
                                        <i class="fas fa-trophy"></i> Declare Winners Now
                                    </button>
                                    <button class="btn btn-outline" onclick="this.closest('.modal').remove()">
                                        <i class="fas fa-times"></i> Close
                                    </button>
                                </div>
                            ` : `
                                <div style="margin-top: 20px;">
                                    <button class="btn btn-outline" onclick="this.closest('.modal').remove()">
                                        <i class="fas fa-times"></i> Close
                                    </button>
                                </div>
                            `}
                        </div>
                    </div>
                `;
            }
            
            // Initial popup content
            updatePopupContent();
            document.body.appendChild(modal);

            // Update countdown every second
            const countdownInterval = setInterval(() => {
                remainingSeconds--;
                
                // Auto-declare winners when timer reaches zero
                if (remainingSeconds <= 0) {
                    clearInterval(countdownInterval);
                    if (modal.parentNode) {
                        modal.remove();
                    }
                    return;
                }
                
                // Update popup content if it still exists
                if (modal.parentNode) {
                    updatePopupContent();
                }
            }, 1000);
        }

        function showContestTimeoutPopup(contestId) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            // Prevent multiple popups for the same contest
            if (contest.popupShown) return;
            contest.popupShown = true;

            // Create timeout popup that stays for 20 minutes
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.style.zIndex = '2000';
            modal.id = `contest-popup-${contestId}`;
            
            let remainingSeconds = 20 * 60; // 20 minutes in seconds
            let autoDeclarationSeconds = 10 * 60; // 10 minutes until auto-declaration
            
            function updatePopupContent() {
                const remainingMinutes = Math.floor(remainingSeconds / 60);
                const remainingSecondsDisplay = remainingSeconds % 60;
                const autoDeclarationMinutes = Math.floor(autoDeclarationSeconds / 60);
                const autoDeclarationSecondsDisplay = autoDeclarationSeconds % 60;
                
                let statusMessage = '';
                let actionSection = '';
                
                if (autoDeclarationSeconds > 0) {
                    statusMessage = `<p style="color: var(--text-light); margin-bottom: 25px; font-size: 1.1rem;">
                        ${contest.title} has ended. Fetching results...
                    </p>
                    <div style="background: var(--background); padding: 20px; border-radius: var(--radius); margin: 20px 0;">
                        <div style="font-size: 1.2rem; font-weight: 600; color: var(--warning); margin-bottom: 10px;">
                            ⏰ Auto-declaration in: ${autoDeclarationMinutes}:${autoDeclarationSecondsDisplay.toString().padStart(2, '0')}
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-light);">
                            Winners will be automatically declared when timer reaches zero
                        </div>
                    </div>`;
                    
                    actionSection = `${isAdmin ? `
                        <div style="margin-top: 25px; display: flex; gap: 15px; justify-content: center;">
                            <button class="btn btn-primary" onclick="forceAdminDeclaration('${contestId}', this.closest('.modal'))">
                                <i class="fas fa-trophy"></i> Declare Winners Now
                            </button>
                            <button class="btn btn-success" onclick="manualWinnerDeclaration('${contestId}', this.closest('.modal'))">
                                <i class="fas fa-hand-paper"></i> Manual Declaration
                            </button>
                            <button class="btn btn-outline" onclick="this.closest('.modal').remove()">
                                <i class="fas fa-times"></i> Close
                            </button>
                        </div>
                    ` : `
                        <div style="margin-top: 20px;">
                            <button class="btn btn-outline" onclick="this.closest('.modal').remove()">
                                <i class="fas fa-times"></i> Close (popup will reappear in 5 minutes)
                            </button>
                        </div>
                    `}`;
                } else {
                    statusMessage = `<p style="color: var(--success); margin-bottom: 25px; font-size: 1.1rem;">
                        <i class="fas fa-check-circle"></i> Winners are being declared automatically...
                    </p>
                    <div style="margin: 25px 0;">
                        <div class="loading-spinner" style="width: 40px; height: 40px; margin: 0 auto;"></div>
                    </div>`;
                    
                    actionSection = `<div style="margin-top: 20px;">
                        <p style="color: var(--text-light); font-size: 0.9rem;">
                            Please wait while we process the results...
                        </p>
                    </div>`;
                }
                
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 500px; text-align: center;">
                        <div style="padding: 40px 30px;">
                            <div style="font-size: 4rem; color: var(--warning); margin-bottom: 20px;">
                                <i class="fas fa-clock"></i>
                            </div>
                            <h2 style="color: var(--text); margin-bottom: 15px;">Contest Ended!</h2>
                            ${statusMessage}
                            <div style="background: rgba(0, 82, 204, 0.1); padding: 15px; border-radius: var(--radius); margin: 20px 0;">
                                <div style="font-size: 0.9rem; color: var(--primary); font-weight: 600;">
                                    Popup closes in: ${remainingMinutes}:${remainingSecondsDisplay.toString().padStart(2, '0')}
                                </div>
                            </div>
                            ${actionSection}
                        </div>
                    </div>
                `;
            }
            
            // Initial popup content
            updatePopupContent();
            document.body.appendChild(modal);

            // Update countdown every second
            const countdownInterval = setInterval(() => {
                remainingSeconds--;
                if (autoDeclarationSeconds > 0) {
                    autoDeclarationSeconds--;
                }
                
                // Auto-declare winners after 10 minutes
                if (autoDeclarationSeconds === 0 && !contest.winnersAutoDeclared) {
                    contest.winnersAutoDeclared = true;
                    console.log(`Auto-declaring winners for contest ${contestId} after 10 minutes`);
                    declareAutomaticWinners(contestId);
                }
                
                // Close popup after 20 minutes
                if (remainingSeconds <= 0) {
                    clearInterval(countdownInterval);
                    if (modal.parentNode) {
                        modal.remove();
                    }
                    // Schedule contest restart after popup closes
                    setTimeout(() => {
                        restartContestCycle(contestId);
                    }, 2000);
                    return;
                }
                
                // Update popup content if it still exists
                if (modal.parentNode) {
                    updatePopupContent();
                }
            }, 1000);

            // If user closes popup before 20 minutes, show reminder after 5 minutes
            modal.addEventListener('remove', function() {
                if (remainingSeconds > 0 && !isAdmin) {
                    setTimeout(() => {
                        if (remainingSeconds > 0 && !contest.winnersAutoDeclared) {
                            // Show reminder popup
                            showContestReminderPopup(contestId, remainingSeconds);
                        }
                    }, 5 * 60 * 1000); // 5 minutes
                }
            });
        }
        
        function showContestReminderPopup(contestId, remainingSeconds) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest || contest.winnersAutoDeclared) return;
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.style.zIndex = '2000';
            
            const remainingMinutes = Math.floor(remainingSeconds / 60);
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px; text-align: center;">
                    <div style="padding: 30px 20px;">
                        <div style="font-size: 3rem; color: var(--primary); margin-bottom: 15px;">
                            <i class="fas fa-bell"></i>
                        </div>
                        <h3 style="color: var(--text); margin-bottom: 15px;">Contest Update</h3>
                        <p style="color: var(--text-light); margin-bottom: 20px;">
                            ${contest.title} results are still being processed.
                        </p>
                        <p style="color: var(--primary); font-weight: 600; margin-bottom: 20px;">
                            Time remaining: ${remainingMinutes} minutes
                        </p>
                        <button class="btn btn-outline btn-full" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-check"></i> Got it
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Auto-close reminder after 30 seconds
            setTimeout(() => {
                if (modal.parentNode) {
                    modal.remove();
                }
            }, 30000);
        }

        function scheduleContestRestart(contestId) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            console.log(`Scheduling restart for contest ${contestId} in 20 minutes`);

            // Clear any existing restart timer for this contest
            if (contestRestartTimers.has(contestId)) {
                clearTimeout(contestRestartTimers.get(contestId));
            }

            // Set 20-minute restart timer
            const restartTimer = setTimeout(() => {
                restartContest(contestId);
                contestRestartTimers.delete(contestId);
            }, 20 * 60 * 1000); // 20 minutes

            contestRestartTimers.set(contestId, restartTimer);
        }

        async function restartContest(contestId) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            console.log(`Restarting contest: ${contestId}`);

            // Prevent multiple restart attempts
            if (contest.restarting) {
                console.log('Contest already restarting, skipping...');
                return;
            }
            contest.restarting = true;

            // If contest had participants but no admin declared results, declare bot winner
            if (contest.status === 'ended' && contest.currentParticipants > 0) {
                declareBotWinner(contestId);
            }

            // Reset contest for fresh start
            const originalTemplate = CONTEST_TEMPLATES.find(t => t.id === contest.id);
            if (originalTemplate) {
                const newContest = {
                    ...originalTemplate,
                    currentParticipants: Math.floor(Math.random() * 20) + 5, // Start with some participants
                    endTime: new Date(Date.now() + originalTemplate.duration),
                    status: 'active',
                    participants: [],
                    createdAt: new Date(),
                    isActive: true,
                    restartCount: (contest.restartCount || 0) + 1
                };

                try {
                    // Save updated contest to Firestore
                    await db.collection('activeContests').doc(contestId).set(newContest);
                    console.log('✅ Contest restart saved to Firestore');
                } catch (error) {
                    console.error('Error saving restarted contest:', error);
                }

                // Replace the old contest with the new one
                const contestIndex = activeContests.findIndex(c => c.id === contestId);
                if (contestIndex !== -1) {
                    activeContests[contestIndex] = newContest;
                }

                // Re-render contests
                renderContests(activeContests);
                if (isAdmin) {
                    renderAdminContests();
                }

                showNotification(`Contest "${contest.title}" has been restarted fresh!`, 'success');
            }
        }

        async function declareBotWinner(contestId) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            console.log(`Auto-declaring winners for contest: ${contestId} after timeout`);

            try {
                // Get real participants from this contest
                const usersSnapshot = await db.collection('users').get();
                const realParticipants = [];

                usersSnapshot.forEach(doc => {
                    const userData = doc.data();
                    const userJoinedContests = userData.joinedContests || [];
                    const contestEntry = userJoinedContests.find(jc => 
                        jc.contestId === contestId && jc.status === 'joined'
                    );

                    if (contestEntry) {
                        realParticipants.push({
                            uid: doc.id,
                            userData: userData,
                            joinCount: userJoinedContests.filter(jc => jc.contestId === contestId).length
                        });
                    }
                });

                console.log(`Found ${realParticipants.length} real participants`);

                // Declare autobot winners for 1st, 2nd, 3rd prizes
                const autobotWinners = [
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[0].amount,
                        date: getTimeAgo(new Date(contest.endTime)),
                        position: '1st Prize',
                        isBot: false,
                        isAutoGenerated: true
                    },
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[1].amount,
                        date: getTimeAgo(new Date(contest.endTime)),
                        position: '2nd Prize',
                        isBot: false,
                        isAutoGenerated: true
                    },
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[2].amount,
                        date: getTimeAgo(new Date(contest.endTime)),
                        position: '3rd Prize',
                        isBot: false,
                        isAutoGenerated: true
                    }
                ];

                // Add autobot winners to display list
                autobotWinners.reverse().forEach(winner => {
                    winners.unshift(winner);
                });

                // Select up to 2 random real winners for 4th prize (compensation)
                const compensationWinners = [];
                if (realParticipants.length > 0) {
                    // Apply the rule: if multiple entries from same contestant, they can get 0-2 wins only
                    const eligibleParticipants = realParticipants.filter(participant => {
                        const maxWinsForUser = Math.min(2, participant.joinCount);
                        const currentWins = compensationWinners.filter(w => w.uid === participant.uid).length;
                        return currentWins < maxWinsForUser;
                    });

                    const shuffled = [...eligibleParticipants].sort(() => Math.random() - 0.5);
                    const winnersToSelect = Math.min(2, shuffled.length);

                    for (let i = 0; i < winnersToSelect; i++) {
                        const winner = shuffled[i];
                        const compensationPrize = contest.prizeStructure[3] ? contest.prizeStructure[3].amount : 500;
                        
                        compensationWinners.push({
                            uid: winner.uid,
                            userData: winner.userData,
                            prize: compensationPrize,
                            position: '4th Prize (Compensation)'
                        });
                    }
                }

                // Process real winner rewards
                if (compensationWinners.length > 0) {
                    const batch = db.batch();

                    for (const winner of compensationWinners) {
                        const userRef = db.collection('users').doc(winner.uid);

                        // Create win transaction
                        const winTransaction = {
                            id: generateTransactionId(),
                            type: 'prize_win',
                            amount: winner.prize,
                            description: `Won ${winner.position} in ${contest.title}`,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                            status: 'completed',
                            contestId: contestId,
                            position: winner.position,
                            date: new Date().toLocaleDateString('en-IN'),
                            time: new Date().toLocaleTimeString('en-IN'),
                            paymentVerified: true
                        };

                        // Update user's joined contests
                        const updatedJoinedContests = winner.userData.joinedContests.map(jc => {
                            if (jc.contestId === contestId && jc.status === 'joined') {
                                return {
                                    ...jc,
                                    status: 'won',
                                    position: winner.position,
                                    prizeWon: winner.prize,
                                    contestState: 'completed'
                                };
                            }
                            return jc;
                        });

                        batch.update(userRef, {
                            balance: firebase.firestore.FieldValue.increment(winner.prize),
                            contestsWon: firebase.firestore.FieldValue.increment(1),
                            totalWinnings: firebase.firestore.FieldValue.increment(winner.prize),
                            joinedContests: updatedJoinedContests,
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });

                        // Add win transaction
                        const winTransactionRef = userRef.collection('transactions').doc();
                        batch.set(winTransactionRef, winTransaction);

                        // Add to winners display list
                        winners.unshift({
                            name: winner.userData.displayName || 'Winner',
                            contest: contest.title,
                            prize: winner.prize,
                            date: getTimeAgo(new Date(contest.endTime)),
                            position: winner.position,
                            isBot: false,
                            isRealWinner: true
                        });

                        console.log(`Real Winner: ${winner.userData.displayName} - ${winner.position} - ₹${winner.prize}`);
                    }

                    await batch.commit();
                    console.log(`Awarded compensation prizes to ${compensationWinners.length} real participants`);
                }

                // Update non-winning participants
                const nonWinners = realParticipants.filter(p => 
                    !compensationWinners.some(w => w.uid === p.uid)
                );

                if (nonWinners.length > 0) {
                    const batch = db.batch();

                    for (const participant of nonWinners) {
                        const userRef = db.collection('users').doc(participant.uid);
                        const updatedJoinedContests = participant.userData.joinedContests.map(jc => {
                            if (jc.contestId === contestId && jc.status === 'joined') {
                                return {
                                    ...jc,
                                    status: 'completed',
                                    position: null,
                                    prizeWon: 0,
                                    contestState: 'completed'
                                };
                            }
                            return jc;
                        });

                        batch.update(userRef, {
                            joinedContests: updatedJoinedContests,
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }

                    await batch.commit();
                }

                // Update contest status
                contest.status = 'completed';
                contest.completedAt = new Date();
                contest.autobotWinners = autobotWinners;
                contest.realWinners = compensationWinners;

                // Save completion status to Firestore
                try {
                    await db.collection('activeContests').doc(contestId).update({
                        status: 'completed',
                        completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        winnersCount: autobotWinners.length + compensationWinners.length,
                        realWinnersCount: compensationWinners.length
                    });
                } catch (error) {
                    console.error('Error updating contest completion status:', error);
                }

                // Keep only recent 20 winners
                if (winners.length > 20) {
                    winners = winners.slice(0, 20);
                }

                // Re-render winners if winners tab is active
                const winnersTab = document.getElementById('winnersTab');
                if (winnersTab && winnersTab.classList.contains('active')) {
                    renderWinners();
                }

                showNotification(`🎉 Contest "${contest.title}" completed! Winners declared: ${autobotWinners.length} main prizes + ${compensationWinners.length} compensation prizes.`, 'success');

                // Refresh current user data if they participated
                if (currentUser && realParticipants.some(p => p.uid === currentUser.uid)) {
                    setTimeout(async () => {
                        try {
                            const userDoc = await db.collection('users').doc(currentUser.uid).get();
                            if (userDoc.exists) {
                                const userData = userDoc.data();
                                userBalance = userData.balance || userBalance;
                                joinedContests = userData.joinedContests || joinedContests;
                                userProfile.contestsWon = userData.contestsWon || userProfile.contestsWon;
                                userProfile.totalWinnings = userData.totalWinnings || userProfile.totalWinnings;

                                document.getElementById('userBalance').textContent = '₹' + userBalance.toLocaleString();
                                renderJoinedContests();
                                updateProfileStats();
                            }
                        } catch (error) {
                            console.error('Error refreshing user data:', error);
                        }
                    }, 1000);
                }

            } catch (error) {
                console.error('Error in declareBotWinner:', error);
                // Fallback: just create autobot winners
                const fallbackWinners = [
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[0].amount,
                        date: getTimeAgo(new Date(contest.endTime)),
                        position: '1st Prize',
                        isBot: false,
                        isAutoGenerated: true
                    }
                ];

                fallbackWinners.forEach(winner => {
                    winners.unshift(winner);
                });

                contest.status = 'completed';
                contest.completedAt = new Date();

                if (winners.length > 20) winners.pop();

                showNotification(`🎉 Contest "${contest.title}" completed! Winner declared.`, 'success');
            }
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

            if (diffMins < 5) return 'Just now';
            if (diffMins < 60) return `${diffMins} minutes ago`;
            if (diffHours < 24) return `${diffHours} hours ago`;
            if (diffDays < 7) return `${diffDays} days ago`;
            return date.toLocaleDateString('en-IN');
        }

        function generateIndianName() {
            // Larger pool of diverse Indian names to avoid repetition
            const indianNames = [
                'Rajesh Kumar', 'Priya Sharma', 'Amit Singh', 'Sneha Patel', 'Vikram Yadav',
                'Anita Gupta', 'Ravi Agarwal', 'Kavya Reddy', 'Suresh Jain', 'Deepika Verma',
                'Arjun Mehta', 'Pooja Shah', 'Manish Tiwari', 'Swati Mishra', 'Karthik Nair',
                'Ritika Joshi', 'Nikhil Bansal', 'Shreya Kapoor', 'Rohit Saxena', 'Meera Sinha',
                'Aditya Krishnan', 'Riya Malhotra', 'Sanjay Pandey', 'Neha Agarwal', 'Varun Chopra',
                'Isha Desai', 'Harish Rao', 'Simran Kaur', 'Akash Thakur', 'Divya Iyer',
                'Mohit Ahluwalia', 'Anjali Bhatt', 'Sachin Goyal', 'Priyanka Sood', 'Rahul Khanna',
                'Tanvi Goel', 'Vishal Anand', 'Kritika Bajaj', 'Kunal Sethi', 'Nandini Chawla',
                'Abhishek Jha', 'Sakshi Mittal', 'Gaurav Bhatia', 'Preeti Agarwal', 'Siddharth Rana',
                'Shweta Dalal', 'Yash Malhotra', 'Richa Sehgal', 'Pankaj Sahni', 'Megha Rastogi'
            ];
            
            // Ensure we don't repeat recent winners
            let attempts = 0;
            let selectedName;
            do {
                selectedName = indianNames[Math.floor(Math.random() * indianNames.length)];
                attempts++;
            } while (attempts < 10 && winners.some(w => w.name === selectedName && w.isAutoGenerated));
            
            return selectedName;
        }

        function adminForceDeclaration(contestId, modalElement = null) {
            if (!isAdmin) {
                showNotification('Only admin can declare contest results', 'error');
                return;
            }

            // Close the popup if provided
            if (modalElement) {
                modalElement.remove();
            }

            // Force declare winners immediately
            console.log(`Admin force declaring winners for contest ${contestId}`);
            declareAutomaticWinners(contestId);
        }

        function adminDeclareContestResults(contestId, modalElement = null) {
            if (!isAdmin) {
                showNotification('Only admin can declare contest results', 'error');
                return;
            }

            // Close the popup if provided
            if (modalElement) {
                modalElement.remove();
            }

            // Cancel the restart timer since admin is taking control
            if (contestRestartTimers.has(contestId)) {
                clearTimeout(contestRestartTimers.get(contestId));
                contestRestartTimers.delete(contestId);
                console.log(`Cancelled auto-restart for contest ${contestId} - admin declaring results`);
            }

            // Call the existing declare results function
            declareAutomaticWinners(contestId);
        }

        function forceAdminDeclaration(contestId, modalElement = null) {
            if (!isAdmin) {
                showNotification('Only admin can declare contest results', 'error');
                return;
            }

            console.log(`Admin force declaring winners for contest ${contestId}`);
            
            // Close the popup if provided
            if (modalElement) {
                modalElement.remove();
            }

            // Force the contest status to ended for declaration
            const contest = activeContests.find(c => c.id === contestId);
            if (contest) {
                contest.status = 'ended';
                contest.endingInProgress = false;
            }

            // Force declare winners immediately
            declareAutomaticWinners(contestId);
            showNotification('Admin forcing winner declaration...', 'success');
        }

        async function manualWinnerDeclaration(contestId, modalElement = null) {
            if (!isAdmin) {
                showNotification('Only admin can declare contest results', 'error');
                return;
            }

            console.log(`Admin manually declaring winners for contest ${contestId}`);
            
            // Close the popup if provided
            if (modalElement) {
                modalElement.remove();
            }

            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            try {
                // Force contest to ended state
                contest.status = 'ended';
                contest.endedAt = new Date();
                contest.endingInProgress = false;

                // Create autobot winners (no database dependency)
                const autobotWinners = [
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[0].amount,
                        date: 'Just now',
                        position: '1st Prize',
                        isBot: false,
                        isAutoGenerated: true
                    },
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[1].amount,
                        date: 'Just now',
                        position: '2nd Prize',
                        isBot: false,
                        isAutoGenerated: true
                    },
                    {
                        name: generateIndianName(),
                        contest: contest.title,
                        prize: contest.prizeStructure[2].amount,
                        date: 'Just now',
                        position: '3rd Prize',
                        isBot: false,
                        isAutoGenerated: true
                    }
                ];

                // Add winners to display list
                autobotWinners.reverse().forEach(winner => {
                    winners.unshift(winner);
                });

                // Mark contest as completed
                contest.status = 'completed';
                contest.completedAt = new Date();
                contest.autobotWinners = autobotWinners;

                // Keep only recent 20 winners
                if (winners.length > 20) {
                    winners = winners.slice(0, 20);
                }

                // Re-render UI
                renderContests(activeContests);
                renderWinners();
                
                if (isAdmin) {
                    renderAdminContests();
                }

                showNotification(`✅ Contest "${contest.title}" manually completed! Winners declared.`, 'success');

            } catch (error) {
                console.error('Error in manual winner declaration:', error);
                showNotification('Manual declaration completed with basic winners', 'success');
            }
        }

        // Add pulse animation for urgent timers
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.5; }
            }
        `;
        document.head.appendChild(style);

        function updateLiveStats() {
            // Update live stats with random increments
            const totalUsersEl = document.getElementById('totalUsers');
            const totalPrizesEl = document.getElementById('totalPrizes');
            const winnersTodayEl = document.getElementById('winnersToday');

            if (totalUsersEl) {
                const currentUsers = parseInt(totalUsersEl.textContent.replace(/,/g, ''));
                totalUsersEl.textContent = (currentUsers + Math.floor(Math.random() * 5)).toLocaleString();
            }

            if (winnersTodayEl) {
                const currentWinners = parseInt(winnersTodayEl.textContent);
                winnersTodayEl.textContent = currentWinners + Math.floor(Math.random() * 3);
            }
        }

        function showAuth() {
            document.getElementById('landingSection').style.display = 'none';
            document.getElementById('authSection').style.display = 'block';
        }

        function toggleAuthForm(formType) {
            const forms = ['loginForm', 'signupForm', 'otpVerification'];
            forms.forEach(form => {
                document.getElementById(form).style.display = 'none';
            });

            if (formType === 'login') {
                document.getElementById('loginForm').style.display = 'block';
            } else if (formType === 'signup') {
                document.getElementById('signupForm').style.display = 'block';
            }
        }

        function togglePasswordVisibility(inputId) {
            const input = document.getElementById(inputId);
            const button = input.nextElementSibling;
            const icon = button.querySelector('i');

            if (input.type === 'password') {
                input.type = 'text';
                icon.classList.replace('fa-eye', 'fa-eye-slash');
            } else {
                input.type = 'password';
                icon.classList.replace('fa-eye-slash', 'fa-eye');
            }
        }

        async function handleLogin(event) {
            event.preventDefault();

            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                showNotification('Please fill in all fields', 'error');
                return;
            }

            try {
                showNotification('Signing in...', 'success');
                await auth.signInWithEmailAndPassword(email, password);
            } catch (error) {
                console.error('Login error:', error);
                let errorMessage = 'Login failed. Please try again.';

                switch (error.code) {
                    case 'auth/user-not-found':
                        errorMessage = 'No account found with this email';
                        break;
                    case 'auth/wrong-password':
                        errorMessage = 'Incorrect password';
                        break;
                    case 'auth/invalid-email':
                        errorMessage = 'Invalid email address';
                        break;
                    case 'auth/too-many-requests':
                        errorMessage = 'Too many failed attempts. Please try again later.';
                        break;
                }

                showNotification(errorMessage, 'error');
            }
        }

        async function handleSignup(event) {
            event.preventDefault();

            const name = document.getElementById('signupName').value.trim();
            const email = document.getElementById('signupEmail').value.trim();
            const password = document.getElementById('signupPassword').value;

            if (!name || !email || !password) {
                showNotification('Please fill in all fields', 'error');
                return;
            }

            if (password.length < 6) {
                showNotification('Password must be at least 6 characters', 'error');
                return;
            }

            try {
                showNotification('Sending verification email...', 'success');

                // Generate and store OTP
                const otp = generateOTP();
                pendingUserData = {
                    name: name,
                    email: email,
                    password: password,
                    otp: otp
                };

                // Send OTP email (simulated)
                sendOTPEmail(email, otp);

                // Show OTP verification form
                document.getElementById('signupForm').style.display = 'none';
                document.getElementById('otpVerification').style.display = 'block';

            } catch (error) {
                console.error('Signup error:', error);
                showNotification('Failed to send verification email. Please try again.', 'error');
            }
        }

        async function handleUserLogin(user) {
            currentUser = user;
            isAdmin = ADMIN_EMAILS.includes(user.email);

            // Update UI
            document.getElementById('landingSection').style.display = 'none';
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('userSection').style.display = 'block';

            // Set user info
            document.getElementById('userDisplayName').textContent = user.displayName || 'Smart Player';
            document.getElementById('userEmail').textContent = user.email || 'user@example.com';
            document.getElementById('userAvatar').textContent = (user.displayName || 'U')[0].toUpperCase();

            // Show admin tab if user is admin
            if (isAdmin) {
                console.log('User is admin, showing admin tab');
                const adminTab = document.getElementById('adminTab');
                if (adminTab) {
                    adminTab.style.display = 'block';
                }
                // Delay admin contests rendering to ensure contests are loaded
                setTimeout(() => {
                    renderAdminContests();
                }, 500);
            } else {
                console.log('User is not admin');
            }

            // Ensure Firestore is ready
            if (!db) {
                console.error('❌ Firestore not initialized');
                showNotification('Database connection failed. Please refresh the page.', 'error');
                return;
            }

            // Load user data from Firestore with improved error handling
            try {
                const userDoc = await db.collection('users').doc(user.uid).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    userBalance = userData.balance || 0;
                    userProfile = {
                        contestsJoined: userData.contestsJoined || 0,
                        contestsWon: userData.contestsWon || 0,
                        totalWinnings: userData.totalWinnings || 0
                    };

                    // Load joined contests
                    joinedContests = userData.joinedContests || [];

                    // Load transactions from sub-collection first, fallback to array
                    try {
                        const transactionsSnapshot = await db.collection('users').doc(user.uid).collection('transactions').orderBy('timestamp', 'desc').limit(50).get();
                        if (!transactionsSnapshot.empty) {
                            transactions = transactionsSnapshot.docs.map(doc => {
                                const data = doc.data();
                                return {
                                    id: doc.id,
                                    ...data,
                                    timestamp: data.timestamp && data.timestamp.toDate ? data.timestamp.toDate() : data.timestamp
                                };
                            });
                        } else {
                            transactions = userData.transactions || [];
                        }
                    } catch (transError) {
                        console.log('Using fallback transactions array');
                        transactions = userData.transactions || [];
                    }

                    // Load withdrawal history including both completed and pending withdrawals
                    withdrawalHistory = transactions.filter(t => t.type === 'withdrawal');
                    
                    // Also load any pending withdrawals for this user
                    try {
                        const pendingWithdrawalsSnapshot = await db.collection('pendingWithdrawals')
                            .where('userId', '==', user.uid)
                            .orderBy('requestedAt', 'desc')
                            .get();
                        
                        if (!pendingWithdrawalsSnapshot.empty) {
                            const pendingWithdrawals = pendingWithdrawalsSnapshot.docs.map(doc => {
                                const data = doc.data();
                                return {
                                    id: doc.id,
                                    type: 'withdrawal',
                                    amount: -Math.abs(data.amount),
                                    description: data.description || `Withdrawal request - ${data.method || 'Bank'}`,
                                    status: data.approvalStatus || 'pending_approval',
                                    date: data.date,
                                    time: data.time,
                                    timestamp: data.requestedAt,
                                    method: data.method,
                                    upiId: data.upiId,
                                    bankAccount: data.bankAccount,
                                    ifscCode: data.ifscCode,
                                    accountName: data.accountName
                                };
                            });
                            
                            // Add pending withdrawals to withdrawal history and transactions if not already present
                            pendingWithdrawals.forEach(pw => {
                                const existsInTransactions = transactions.find(t => t.id === pw.id);
                                const existsInWithdrawals = withdrawalHistory.find(w => w.id === pw.id);
                                
                                if (!existsInWithdrawals) {
                                    withdrawalHistory.unshift(pw);
                                }
                                if (!existsInTransactions) {
                                    transactions.unshift(pw);
                                }
                            });
                        }
                    } catch (pendingError) {
                        console.log('Could not load pending withdrawals:', pendingError);
                    }

                    document.getElementById('userBalance').textContent = '₹' + userBalance.toLocaleString();
                    updateProfileStats();
                    renderTransactions();
                    renderJoinedContests();
                    
                    // Force update profile tab if it's currently active
                    const profileTab = document.getElementById('profileTab');
                    if (profileTab && profileTab.classList.contains('active')) {
                        updateProfileStats();
                    }
                    
                    console.log('✅ User data loaded successfully');
                } else {
                    // Create user document if it doesn't exist
                    await db.collection('users').doc(user.uid).set({
                        displayName: user.displayName || 'Smart Player',
                        email: user.email,
                        balance: 0,
                        contestsJoined: 0,
                        contestsWon: 0,
                        totalWinnings: 0,
                        transactions: [],
                        joinedContests: [],
                        emailVerified: true,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    userBalance = 0;
                    transactions = [];
                    joinedContests = [];
                    document.getElementById('userBalance').textContent = '₹0';
                    renderJoinedContests();
                    console.log('✅ New user document created');
                }
            } catch (error) {
                console.error('❌ Error loading user data:', error);

                // Check if it's a permission error
                if (error.code === 'permission-denied') {
                    showNotification('Database permissions error. Please check Firestore security rules.', 'error');
                } else {
                    showNotification('Failed to load user data. Some features may not work properly.', 'error');
                }

                userBalance = 0;
                transactions = [];
                joinedContests = [];
                document.getElementById('userBalance').textContent = '₹0';
                renderJoinedContests();
            }

            renderWinners();
            
            // Start contest timers when user logs in
            setTimeout(() => {
                if (document.getElementById('contestsTab')?.classList.contains('active')) {
                    startContestTimers();
                }
            }, 1000);
            
            showNotification('Welcome back! 🎉', 'success');
        }

        async function handleLogout() {
            try {
                await auth.signOut();
            } catch (error) {
                console.error('Logout error:', error);
            }
        }

        function handleUserLogout() {
            currentUser = null;
            userBalance = 0;
            isAdmin = false;
            joinedContests = [];

            // Clear timers
            if (contestTimerInterval) {
                clearInterval(contestTimerInterval);
                contestTimerInterval = null;
            }

            // Reset UI
            document.getElementById('landingSection').style.display = 'block';
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('userSection').style.display = 'none';

            // Clear forms
            document.querySelectorAll('.form-input').forEach(input => input.value = '');

            // Reset to terms agreement
            document.getElementById('termsAgreement').style.display = 'block';
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('signupForm').style.display = 'none';
            document.getElementById('otpVerification').style.display = 'none';

            showNotification('Logged out successfully', 'success');
        }

        function switchTab(tabName) {
            console.log('Switching to tab:', tabName);

            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            event.target.classList.add('active');
            const tabContent = document.getElementById(tabName + 'Tab');
            if (tabContent) {
                tabContent.classList.add('active');
            }

            // Refresh data when switching to specific tabs
            if (tabName === 'joinedContests') {
                renderJoinedContests();
            } else if (tabName === 'transactions') {
                renderTransactions();
            } else if (tabName === 'winners') {
                renderWinners();
            } else if (tabName === 'withdrawal') {
                fetchWithdrawalHistory();
            } else if (tabName === 'admin') {
                console.log('Admin tab clicked, isAdmin:', isAdmin);
                if (isAdmin) {
                    renderAdminContests();
                    if (isAdmin) {
                        loadPendingWithdrawals();
                    }
                } else {
                    showNotification('Access denied: Admin privileges required', 'error');
                }
            } else if (tabName === 'contests') {
                renderContests(activeContests);
                // Start timers when contests tab is active
                startContestTimers();
            }
        }

        function togglePrizeDetails(contestId) {
            const prizeDetails = document.getElementById(`prize-${contestId}`);
            const chevron = document.getElementById(`chevron-${contestId}`);

            if (prizeDetails && chevron) {
                if (prizeDetails.classList.contains('show')) {
                    prizeDetails.classList.remove('show');
                    chevron.classList.replace('fa-chevron-up', 'fa-chevron-down');
                } else {
                    prizeDetails.classList.add('show');
                    chevron.classList.replace('fa-chevron-down', 'fa-chevron-up');
                }
            }
        }

        async function joinContest(contestId, entryFee) {
            if (!currentUser) {
                showNotification('Please login first', 'error');
                return;
            }

            if (userBalance < entryFee) {
                showNotification('Insufficient balance. Please add money to your wallet.', 'error');
                openModal('addMoneyModal');
                return;
            }

            try {
                showNotification('Joining contest...', 'success');

                const userRef = db.collection('users').doc(currentUser.uid);

                // Create transaction for contest entry
                const transaction = {
                    id: generateTransactionId(),
                    type: 'contest_entry',
                    amount: -entryFee,
                    description: `Joined contest: ${CONTEST_TEMPLATES.find(c => c.id === contestId)?.title || contestId}`,
                    timestamp: new Date(),
                    status: 'completed',
                    contestId: contestId,
                    date: new Date().toLocaleDateString('en-IN'),
                    time: new Date().toLocaleTimeString('en-IN'),
                    paymentVerified: true
                };

                // Create joined contest entry with enhanced tracking
                const joinedContest = {
                    contestId: contestId,
                    joinedDate: new Date().toLocaleDateString('en-IN'),
                    joinedTime: new Date().toLocaleTimeString('en-IN'),
                    entryFee: entryFee,
                    status: 'joined',
                    prizeWon: 0,
                    position: null,
                    contestState: 'active',
                    joinTimestamp: new Date().getTime()
                };

                // Use a batch operation for better reliability
                const batch = db.batch();

                batch.update(userRef, {
                    balance: firebase.firestore.FieldValue.increment(-entryFee),
                    contestsJoined: firebase.firestore.FieldValue.increment(1),
                    joinedContests: firebase.firestore.FieldValue.arrayUnion(joinedContest),
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Add transaction to sub-collection
                const transactionRef = userRef.collection('transactions').doc();
                batch.set(transactionRef, transaction);

                // Commit the batch
                await batch.commit();

                // Update local state
                userBalance -= entryFee;
                userProfile.contestsJoined++;
                joinedContests.unshift(joinedContest);

                transactions.unshift(transaction);

                document.getElementById('userBalance').textContent = '₹' + userBalance.toLocaleString();
                updateProfileStats();
                renderTransactions();
                renderJoinedContests();

                showNotification('✅ Successfully joined the contest!', 'success');

                // Contest results will be declared only when contest is full or time expires
                // Check if contest is now full and trigger result if needed
                checkAndDeclareContestResult(contestId);

            } catch (error) {
                console.error('❌ Error joining contest:', error);

                if (error.code === 'permission-denied') {
                    showNotification('Permission denied. Please check your account permissions.', 'error');
                } else {
                    showNotification('Failed to join contest: ' + error.message, 'error');
                }
            }
        }

        async function checkAndDeclareContestResult(contestId) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            // Update participant count
            contest.currentParticipants++;

            // Check if contest is full or time expired
            const isContestFull = contest.currentParticipants >= contest.maxParticipants;
            const isTimeExpired = new Date() >= new Date(contest.endTime);

            if (isContestFull || isTimeExpired) {
                console.log(`Contest ${contestId} is ready for result declaration`);
                // Mark contest as ready for admin declaration
                contest.status = 'ready_for_declaration';
                
                // Never auto-declare results for real users - only admin can do this
                // This ensures fair play and proper oversight
            }

            // Re-render contests to update UI
            renderContests(activeContests);
        }

        async function declareContestResults(contestId) {
            if (!isAdmin) {
                showNotification('Only admin can declare contest results', 'error');
                return;
            }

            const contest = CONTEST_TEMPLATES.find(c => c.id === contestId);
            if (!contest) return;

            try {
                console.log(`Admin declaring results for contest: ${contestId}`);
                showNotification('Admin declaring contest results...', 'success');

                // Cancel any pending restart timer since admin is taking control
                if (contestRestartTimers.has(contestId)) {
                    clearTimeout(contestRestartTimers.get(contestId));
                    contestRestartTimers.delete(contestId);
                    console.log(`Cancelled auto-restart for contest ${contestId} - admin declaring results`);
                }

                // Get all participants for this contest from Firestore
                const usersSnapshot = await db.collection('users')
                    .where('joinedContests', 'array-contains-any', [
                        { contestId: contestId, status: 'joined' }
                    ])
                    .get();

                if (usersSnapshot.empty) {
                    console.log('No participants found for contest');
                    showNotification('No participants found in this contest. Contest will restart automatically.', 'error');
                    // Auto-restart contest with no participants
                    setTimeout(() => restartContest(contestId), 3000);
                    return;
                }

                const participants = [];
                usersSnapshot.forEach(doc => {
                    const userData = doc.data();
                    const userJoinedContests = userData.joinedContests || [];
                    const hasJoinedContest = userJoinedContests.some(jc => 
                        jc.contestId === contestId && jc.status === 'joined'
                    );

                    if (hasJoinedContest) {
                        participants.push({
                            uid: doc.id,
                            userData: userData
                        });
                    }
                });

                if (participants.length === 0) {
                    console.log('No valid participants found');
                    return;
                }

                // Shuffle participants for random selection
                const shuffledParticipants = [...participants].sort(() => Math.random() - 0.5);

                // Define realistic win probabilities based on contest size
                const participantCount = participants.length;
                const winProbabilities = {
                    '1st Prize': Math.min(1 / participantCount, 0.001), // 1 in participants or 0.1% max
                    '2nd Prize': Math.min(2 / participantCount, 0.002), // 2 in participants or 0.2% max
                    '3rd Prize': Math.min(5 / participantCount, 0.005), // 5 in participants or 0.5% max
                    'Consolation': Math.min(20 / participantCount, 0.15) // 20 in participants or 15% max
                };

                const winners = [];
                const batch = db.batch();

                // Process each participant with realistic probabilities
                for (let i = 0; i < shuffledParticipants.length; i++) {
                    const participant = shuffledParticipants[i];
                    const random = Math.random();

                    let position = null;
                    let prize = 0;

                    // Apply realistic probabilities - most users won't win
                    if (random < winProbabilities['2nd Prize'] && !winners.find(w => w.position === '2nd Prize')) {
                        position = '2nd Prize';
                        prize = contest.prizeStructure[1].amount;
                    } else if (random < winProbabilities['3rd Prize'] && !winners.find(w => w.position === '3rd Prize')) {
                        position = '3rd Prize';
                        prize = contest.prizeStructure[2].amount;
                    } else if (random < winProbabilities['Consolation'] && winners.filter(w => w.position.includes('Consolation')).length < 10) {
                        position = contest.prizeStructure[3].position;
                        prize = contest.prizeStructure[3].amount;
                    }

                    const userRef = db.collection('users').doc(participant.uid);

                    if (position && prize > 0) {
                        // Winner - update with prize
                        const winTransaction = {
                            id: generateTransactionId(),
                            type: 'prize_win',
                            amount: prize,
                            description: `Won ${position} in ${contest.title}`,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                            status: 'completed',
                            contestId: contestId,
                            position: position,
                            date: new Date().toLocaleDateString('en-IN'),
                            time: new Date().toLocaleTimeString('en-IN'),
                            paymentVerified: true
                        };

                        // Update user's joined contests
                        const updatedJoinedContests = participant.userData.joinedContests.map(jc => {
                            if (jc.contestId === contestId && jc.status === 'joined') {
                                return {
                                    ...jc,
                                    status: 'won',
                                    position: position,
                                    prizeWon: prize,
                                    contestState: 'completed'
                                };
                            }
                            return jc;
                        });

                        batch.update(userRef, {
                            balance: firebase.firestore.FieldValue.increment(prize),
                            contestsWon: firebase.firestore.FieldValue.increment(1),
                            totalWinnings: firebase.firestore.FieldValue.increment(prize),
                            joinedContests: updatedJoinedContests,
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });

                        // Add win transaction
                        const winTransactionRef = userRef.collection('transactions').doc();
                        batch.set(winTransactionRef, winTransaction);

                        winners.push({
                            uid: participant.uid,
                            position: position,
                            prize: prize
                        });

                        console.log(`Winner: ${participant.uid} - ${position} - ₹${prize}`);
                    } else {
                        // Non-winner - just update contest status
                        const updatedJoinedContests = participant.userData.joinedContests.map(jc => {
                            if (jc.contestId === contestId && jc.status === 'joined') {
                                return {
                                    ...jc,
                                    status: 'completed',
                                    position: null,
                                    prizeWon: 0,
                                    contestState: 'completed'
                                };
                            }
                            return jc;
                        });

                        batch.update(userRef, {
                            joinedContests: updatedJoinedContests,
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }

                // Commit all updates
                await batch.commit();

                // Update contest status
                const contestIndex = activeContests.findIndex(c => c.id === contestId);
                if (contestIndex !== -1) {
                    activeContests[contestIndex].status = 'completed';
                    
                    // Save completion status to Firestore
                    try {
                        await db.collection('activeContests').doc(contestId).update({
                            status: 'completed',
                            completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            winnersCount: winners.length
                        });
                    } catch (error) {
                        console.error('Error updating contest completion status:', error);
                    }
                }

                // Add winners to recent winners list with realistic timing
                const contestWinners = [];
                for (let i = 0; i < Math.min(winners.length, 3); i++) {
                    const winner = winners[i];
                    const winnerData = participants.find(p => p.uid === winner.uid);
                    if (winnerData) {
                        contestWinners.push({
                            name: winnerData.userData.displayName || 'Winner',
                            contest: contest.title,
                            prize: winner.prize,
                            date: getTimeAgo(new Date(contest.endTime || Date.now())),
                            position: winner.position,
                            isBot: false,
                            contestEndTime: contest.endTime
                        });
                    }
                }

                // Add to global winners list
                contestWinners.reverse().forEach(w => {
                    winners.unshift(w);
                });
                if (winners.length > 20) {
                    winners = winners.slice(0, 20);
                }

                showNotification(`✅ Contest results declared! ${winners.length} winners selected.`, 'success');

                // Refresh UI for current user if they participated
                if (currentUser) {
                    const userDoc = await db.collection('users').doc(currentUser.uid).get();
                    if (userDoc.exists) {
                        const userData = userDoc.data();
                        userBalance = userData.balance || userBalance;
                        joinedContests = userData.joinedContests || joinedContests;

                        document.getElementById('userBalance').textContent = '₹' + userBalance.toLocaleString();
                        renderJoinedContests();
                        renderTransactions();
                        updateProfileStats();
                    }
                }

                // Update winners display if active
                const winnersTab = document.getElementById('winnersTab');
                if (winnersTab && winnersTab.classList.contains('active')) {
                    renderWinners();
                }

                renderContests(activeContests);

            } catch (error) {
                console.error('❌ Error declaring contest results:', error);
                showNotification('Failed to declare contest results', 'error');
            }
        }

        function renderWinners() {
            const winnersList = document.getElementById('winnersList');
            if (!winnersList) return;

            winnersList.innerHTML = '';

            // Add live winners header
            const winnersHeader = document.createElement('div');
            winnersHeader.style.textAlign = 'center';
            winnersHeader.style.padding = '20px';
            winnersHeader.style.background = 'linear-gradient(135deg, var(--primary), var(--accent))';
            winnersHeader.style.borderRadius = 'var(--radius-lg)';
            winnersHeader.style.marginBottom = '20px';
            winnersHeader.style.color = 'white';
            winnersHeader.innerHTML = `
                <h2 style="margin: 0 0 10px 0; font-size: 1.8rem;">
                    <i class="fas fa-crown" style="margin-right: 10px;"></i>
                    Recent Winners
                </h2>
                <p style="margin: 0; opacity: 0.9;">Live contest results from completed contests</p>
            `;
            winnersList.appendChild(winnersHeader);

            if (winners.length === 0) {
                const noWinners = document.createElement('div');
                noWinners.className = 'data-item';
                noWinners.innerHTML = `
                    <div class="data-item-info" style="text-align: center; padding: 40px;">
                        <div class="data-item-title" style="color: var(--text-light);">
                            <i class="fas fa-trophy" style="font-size: 2rem; margin-bottom: 15px; opacity: 0.5;"></i><br>
                            No winners yet
                        </div>
                        <div class="data-item-subtitle">Winners will appear here when contests are completed</div>
                    </div>
                `;
                winnersList.appendChild(noWinners);
                return;
            }

            winners.forEach((winner, index) => {
                const winnerItem = document.createElement('div');
                winnerItem.className = 'data-item';
                
                // Add position badge for top 3 (no bot indicators)
                let positionBadge = '';
                if (index === 0) {
                    positionBadge = `<span style="background: gold; color: #000; font-size: 0.7rem; padding: 3px 8px; border-radius: 12px; margin-left: 8px; font-weight: 600;">🥇 NEW</span>`;
                } else if (index === 1) {
                    positionBadge = `<span style="background: silver; color: #000; font-size: 0.7rem; padding: 3px 8px; border-radius: 12px; margin-left: 8px; font-weight: 600;">🥈</span>`;
                } else if (index === 2) {
                    positionBadge = `<span style="background: #cd7f32; color: #fff; font-size: 0.7rem; padding: 3px 8px; border-radius: 12px; margin-left: 8px; font-weight: 600;">🥉</span>`;
                }

                winnerItem.innerHTML = `
                    <div class="data-item-info">
                        <div class="data-item-title">
                            ${winner.name}${positionBadge}
                            ${winner.position ? `<span style="color: var(--warning); font-size: 0.9rem; margin-left: 8px;">(${winner.position})</span>` : ''}
                        </div>
                        <div class="data-item-subtitle">${winner.contest} • ${winner.date}</div>
                    </div>
                    <div class="data-item-value" style="color: var(--success); font-weight: 700;">
                        ₹${winner.prize.toLocaleString()}
                    </div>
                `;
                winnersList.appendChild(winnerItem);
            });

            }

        function renderAdminContests() {
            if (!isAdmin) {
                console.log('User is not admin, skipping admin contests render');
                const adminContestsList = document.getElementById('adminContestsList');
                if (adminContestsList) {
                    adminContestsList.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: var(--error);">
                            <i class="fas fa-ban" style="font-size: 3rem; margin-bottom: 20px;"></i>
                            <h3>Access Denied</h3>
                            <p>You don't have admin permissions to access this section.</p>
                        </div>
                    `;
                }
                return;
            }

            const adminContestsList = document.getElementById('adminContestsList');
            if (!adminContestsList) {
                console.log('Admin contests list element not found');
                return;
            }

            console.log('Rendering admin contests, total contests:', activeContests.length);
            adminContestsList.innerHTML = '';

            // Add admin dashboard header
            const adminHeader = document.createElement('div');
            adminHeader.style.marginBottom = '30px';
            adminHeader.style.padding = '25px';
            adminHeader.style.background = 'linear-gradient(135deg, var(--primary), var(--accent))';
            adminHeader.style.borderRadius = 'var(--radius-lg)';
            adminHeader.style.color = 'white';
            adminHeader.style.textAlign = 'center';
            adminHeader.innerHTML = `
                <h2 style="margin: 0 0 10px 0; font-size: 1.8rem;">
                    <i class="fas fa-crown" style="margin-right: 10px;"></i>
                    Admin Dashboard
                </h2>
                <p style="margin: 0; opacity: 0.9;">Manage contests, declare winners, and oversee lottery operations</p>
            `;
            adminContestsList.appendChild(adminHeader);

            // Add quick stats
            const quickStats = document.createElement('div');
            quickStats.style.marginBottom = '30px';
            quickStats.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                    <div style="background: var(--surface); padding: 20px; border-radius: var(--radius-lg); text-align: center; box-shadow: var(--shadow);">
                        <div style="font-size: 2rem; font-weight: 800; color: var(--primary);">${activeContests.length}</div>
                        <div style="color: var(--text-light);">Active Contests</div>
                    </div>
                    <div style="background: var(--surface); padding: 20px; border-radius: var(--radius-lg); text-align: center; box-shadow: var(--shadow);">
                        <div style="font-size: 2rem; font-weight: 800; color: var(--success);">${activeContests.reduce((sum, c) => sum + c.currentParticipants, 0)}</div>
                        <div style="color: var(--text-light);">Total Participants</div>
                    </div>
                    <div style="background: var(--surface); padding: 20px; border-radius: var(--radius-lg); text-align: center; box-shadow: var(--shadow);">
                        <div style="font-size: 2rem; font-weight: 800; color: var(--warning);">₹${activeContests.reduce((sum, c) => sum + c.prizePool, 0).toLocaleString()}</div>
                        <div style="color: var(--text-light);">Total Prize Pool</div>
                    </div>
                    <div style="background: var(--surface); padding: 20px; border-radius: var(--radius-lg); text-align: center; box-shadow: var(--shadow);">
                        <div style="font-size: 2rem; font-weight: 800; color: var(--error);">${activeContests.filter(c => c.status === 'ready_for_declaration' || c.currentParticipants >= c.maxParticipants).length}</div>
                        <div style="color: var(--text-light);">Ready for Results</div>
                    </div>
                </div>
            `;
            adminContestsList.appendChild(quickStats);

            if (activeContests.length === 0) {
                const noContests = document.createElement('div');
                noContests.style.textAlign = 'center';
                noContests.style.padding = '40px';
                noContests.style.background = 'var(--surface)';
                noContests.style.borderRadius = 'var(--radius-lg)';
                noContests.style.boxShadow = 'var(--shadow)';
                noContests.innerHTML = `
                    <i class="fas fa-trophy" style="font-size: 3rem; margin-bottom: 20px; opacity: 0.3; color: var(--text-light);"></i>
                    <h3 style="color: var(--text); margin-bottom: 10px;">No Active Contests</h3>
                    <p style="color: var(--text-light); margin-bottom: 20px;">Create your first contest to get started with the lottery system</p>
                    <button class="btn btn-primary" onclick="createNewContest()">
                        <i class="fas fa-plus"></i> Create First Contest
                    </button>
                `;
                adminContestsList.appendChild(noContests);
                return;
            }

            // Show all contests with comprehensive admin information
            activeContests.forEach(contest => {
                const contestItem = document.createElement('div');
                contestItem.className = 'contest-admin-card';
                contestItem.style.marginBottom = '25px';
                contestItem.style.padding = '30px';
                contestItem.style.border = '2px solid var(--border)';
                contestItem.style.borderRadius = 'var(--radius-lg)';
                contestItem.style.background = 'var(--surface)';
                contestItem.style.boxShadow = 'var(--shadow)';

                const timeRemaining = getTimeRemaining(contest.endTime);
                const progressPercentage = Math.min((contest.currentParticipants / contest.maxParticipants) * 100, 100);
                const canDeclareResult = contest.status !== 'completed' && (
                    contest.status === 'ready_for_declaration' || 
                    contest.currentParticipants >= contest.maxParticipants ||
                    new Date() >= new Date(contest.endTime)
                );

                const statusColor = contest.status === 'active' ? 'var(--success)' : 
                                  contest.status === 'completed' ? 'var(--secondary)' : 'var(--warning)';

                contestItem.innerHTML = `
                    <div style="margin-bottom: 25px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                            <div class="data-item-title" style="font-size: 1.4rem; margin: 0; flex: 1;">
                                <i class="fas fa-trophy" style="color: var(--primary); margin-right: 10px;"></i>
                                ${contest.title}
                            </div>
                            <div style="padding: 6px 12px; background: ${statusColor}; color: white; border-radius: 20px; font-size: 0.85rem; font-weight: 600; text-transform: uppercase;">
                                ${contest.status || 'Active'}
                            </div>
                        </div>
                        
                        <div class="data-item-subtitle" style="margin-bottom: 20px; font-size: 1rem;">
                            <strong>Contest ID:</strong> ${contest.id} • 
                            <strong>Entry Fee:</strong> ₹${contest.entryFee} • 
                            <strong>Prize Pool:</strong> ₹${contest.prizePool.toLocaleString()}
                        </div>

                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 25px;">
                            <div style="background: var(--background); padding: 18px; border-radius: var(--radius); text-align: center; border: 1px solid var(--border);">
                                <div style="font-size: 1.3rem; font-weight: 700; color: var(--primary); margin-bottom: 5px;">${contest.currentParticipants}</div>
                                <div style="font-size: 0.9rem; color: var(--text-light);">Current Participants</div>
                            </div>
                            <div style="background: var(--background); padding: 18px; border-radius: var(--radius); text-align: center; border: 1px solid var(--border);">
                                <div style="font-size: 1.3rem; font-weight: 700; color: var(--primary); margin-bottom: 5px;">${contest.maxParticipants}</div>
                                <div style="font-size: 0.9rem; color: var(--text-light);">Max Participants</div>
                            </div>
                            <div style="background: var(--background); padding: 18px; border-radius: var(--radius); text-align: center; border: 1px solid var(--border);">
                                <div style="font-size: 1.3rem; font-weight: 700; color: var(--success); margin-bottom: 5px;">${Math.round(progressPercentage)}%</div>
                                <div style="font-size: 0.9rem; color: var(--text-light);">Filled</div>
                            </div>
                            <div style="background: var(--background); padding: 18px; border-radius: var(--radius); text-align: center; border: 1px solid var(--border);">
                                <div style="font-size: 1.3rem; font-weight: 700; color: ${timeRemaining === 'Ended' ? 'var(--error)' : 'var(--warning)'}; margin-bottom: 5px;">${timeRemaining}</div>
                                <div style="font-size: 0.9rem; color: var(--text-light);">Time Left</div>
                            </div>
                        </div>

                        <div style="background: var(--background); padding: 20px; border-radius: var(--radius); margin-bottom: 25px; border: 1px solid var(--border);">
                            <div style="font-weight: 600; margin-bottom: 15px; color: var(--primary); font-size: 1.1rem;">
                                <i class="fas fa-gift" style="margin-right: 8px;"></i>Prize Distribution:
                            </div>
                            ${contest.prizeStructure.map(prize => `
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; padding: 8px 0; border-bottom: 1px solid var(--border);">
                                    <span style="font-weight: 500;">${prize.position}</span>
                                    <span style="font-weight: 700; color: var(--success);">₹${prize.amount.toLocaleString()}</span>
                                </div>
                            `).join('')}
                        </div>

                        <div style="margin-bottom: 25px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <span style="font-weight: 600;"><i class="fas fa-info-circle" style="margin-right: 5px; color: var(--primary);"></i>Contest Details:</span>
                                <span style="font-size: 0.9rem; color: var(--text-light);"><strong>End Time:</strong> ${new Date(contest.endTime).toLocaleString('en-IN')}</span>
                            </div>
                            <div class="progress-bar" style="height: 12px; margin-bottom: 10px;">
                                <div class="progress-fill" style="width: ${progressPercentage}%; background: linear-gradient(90deg, var(--success), var(--primary));"></div>
                            </div>
                            <div style="font-size: 0.9rem; color: var(--text-light); text-align: center;">
                                ${contest.currentParticipants} of ${contest.maxParticipants} participants joined
                            </div>
                        </div>
                    </div>

                    <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap; padding-top: 20px; border-top: 2px solid var(--border);">
                        ${contest.status === 'active' ? `
                            <button class="btn btn-primary" onclick="adminEndContest('${contest.id}')" style="flex: 1; min-width: 160px;">
                                <i class="fas fa-stop-circle"></i> End Contest
                            </button>
                            <button class="btn btn-success" onclick="forceAdminDeclaration('${contest.id}')" style="flex: 1; min-width: 160px;">
                                <i class="fas fa-trophy"></i> Force Declare
                            </button>
                        ` : contest.status === 'ended' ? `
                            <button class="btn btn-primary" onclick="forceAdminDeclaration('${contest.id}')" style="flex: 1; min-width: 160px;">
                                <i class="fas fa-trophy"></i> Declare Winners
                            </button>
                            <button class="btn btn-success" onclick="manualWinnerDeclaration('${contest.id}')" style="flex: 1; min-width: 160px;">
                                <i class="fas fa-hand-paper"></i> Manual Declare
                            </button>
                        ` : `
                            <button class="btn btn-secondary" onclick="adminRestartContest('${contest.id}')" style="flex: 1; min-width: 160px;">
                                <i class="fas fa-refresh"></i> Restart Contest
                            </button>
                        `}

                        <button class="btn btn-outline" onclick="viewContestParticipants('${contest.id}')" style="flex: 1; min-width: 140px;">
                            <i class="fas fa-users"></i> View Participants
                        </button>

                        <button class="btn btn-outline" onclick="editContestDetails('${contest.id}')" style="flex: 1; min-width: 120px;">
                            <i class="fas fa-edit"></i> Edit
                        </button>

                        ${contest.status === 'active' ? `
                            <button class="btn btn-outline" onclick="pauseContest('${contest.id}')" 
                                    style="border-color: var(--warning); color: var(--warning); min-width: 120px;">
                                <i class="fas fa-pause"></i> Pause
                            </button>
                        ` : ''}

                        <button class="btn btn-outline" onclick="forceEndContest('${contest.id}')" 
                                style="border-color: var(--error); color: var(--error); min-width: 120px;"
                                ${contest.status === 'completed' ? 'disabled' : ''}>
                            <i class="fas fa-stop"></i> Force End
                        </button>
                    </div>
                `;
                adminContestsList.appendChild(contestItem);
            });

            // Add contest management section
            const managementSection = document.createElement('div');
            managementSection.style.marginTop = '40px';
            managementSection.style.padding = '30px';
            managementSection.style.background = 'var(--surface)';
            managementSection.style.borderRadius = 'var(--radius-lg)';
            managementSection.style.boxShadow = 'var(--shadow)';
            managementSection.style.border = '2px dashed var(--primary)';
            managementSection.innerHTML = `
                <h3 style="margin-bottom: 20px; color: var(--primary); text-align: center; font-size: 1.5rem;">
                    <i class="fas fa-plus-circle"></i> Contest Management
                </h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <button class="btn btn-success" onclick="createNewContest()" style="padding: 20px;">
                        <i class="fas fa-plus"></i> Create New Contest
                    </button>
                    <button class="btn btn-primary" onclick="manageAllContests()" style="padding: 20px;">
                        <i class="fas fa-cogs"></i> Manage All Contests
                    </button>
                    <button class="btn btn-outline" onclick="exportContestData()" style="padding: 20px;">
                        <i class="fas fa-download"></i> Export Data
                    </button>
                    <button class="btn btn-secondary" onclick="adminSettings()" style="padding: 20px;">
                        <i class="fas fa-tools"></i> Admin Settings
                    </button>
                </div>
            `;
            adminContestsList.appendChild(managementSection);
        }

        function renderTransactions() {
            const transactionsList = document.getElementById('transactionsList');
            if (!transactionsList) return;

            transactionsList.innerHTML = '';

            if (transactions.length === 0) {
                transactionsList.innerHTML = '<div class="data-item"><div class="data-item-info">No transactions yet</div></div>';
                return;
            }

            transactions.slice(0, 10).forEach(transaction => {
                const transactionItem = document.createElement('div');
                transactionItem.className = 'data-item';
                const amountClass = transaction.amount > 0 ? 'positive' : 'negative';
                const amountPrefix = transaction.amount > 0 ? '+' : '';

                // Payment verification badge
                let verificationBadge = '';
                if (transaction.type === 'money_added' || transaction.type === 'contest_entry') {
                    const verified = transaction.paymentVerified || transaction.status === 'completed';
                    const badgeClass = verified ? 'verified' : 'pending';
                    const badgeText = verified ? 'Verified' : 'Pending';
                    verificationBadge = `<span class="payment-verification-badge ${badgeClass}">${badgeText}</span>`;
                } else if (transaction.type === 'withdrawal') {
                    let badgeClass = '';
                    let badgeText = '';
                    
                    switch (transaction.status) {
                        case 'pending_approval':
                            badgeClass = 'pending';
                            badgeText = 'Pending Approval';
                            break;
                        case 'approved':
                            badgeClass = 'approved';
                            badgeText = 'Approved';
                            break;
                        case 'processing':
                            badgeClass = 'processing';
                            badgeText = 'Processing';
                            break;
                        case 'completed':
                            badgeClass = 'verified';
                            badgeText = 'Completed';
                            break;
                        case 'rejected':
                            badgeClass = 'rejected';
                            badgeText = 'Rejected';
                            break;
                        default:
                            badgeClass = 'pending';
                            badgeText = 'Processing';
                    }
                    
                    verificationBadge = `<span class="payment-verification-badge ${badgeClass}">${badgeText}</span>`;
                }

                transactionItem.innerHTML = `
                    <div class="data-item-info">
                        <div class="data-item-title">${transaction.description}${verificationBadge}</div>
                        <div class="data-item-subtitle">${transaction.date || 'Recent'} • ${transaction.time || ''} • ${transaction.status}</div>
                    </div>
                    <div class="data-item-value transaction-amount ${amountClass}">
                        ${amountPrefix}₹${Math.abs(transaction.amount).toLocaleString()}
                    </div>
                `;
                transactionsList.appendChild(transactionItem);
            });
        }

        function updateProfileStats() {
            document.getElementById('profileContestsJoined').textContent = userProfile.contestsJoined;
            document.getElementById('profileContestsWon').textContent = userProfile.contestsWon;
            document.getElementById('profileTotalWinnings').textContent = '₹' + userProfile.totalWinnings.toLocaleString();

            const winRate = userProfile.contestsJoined > 0 ? 
                Math.round((userProfile.contestsWon / userProfile.contestsJoined) * 100) : 0;
            document.getElementById('profileWinRate').textContent = winRate + '%';
        }

        function selectWithdrawalMethod(method) {
            // Only netbanking method is available now
            currentWithdrawalMethod = 'netbanking';
            
            // Always show bank fields since we only have one method
            const bankFields = document.getElementById('bankWithdrawalFields');
            if (bankFields) {
                bankFields.style.display = 'block';
            }
        }

        async function handleWithdrawal() {
            if (!currentUser) {
                showNotification('Please login first', 'error');
                return;
            }

            const amount = parseInt(document.getElementById('withdrawalAmount').value);

            if (!amount || amount < 500) {
                showNotification('Minimum withdrawal amount is ₹500', 'error');
                return;
            }

            if (amount > userBalance) {
                showNotification('Insufficient balance', 'error');
                return;
            }

            const account = document.getElementById('withdrawalAccount').value.trim();
            const ifsc = document.getElementById('withdrawalIFSC').value.trim();
            const accountName = document.getElementById('withdrawalAccountName').value.trim();
            const upiId = document.getElementById('withdrawalUPI').value.trim();

            if (!account || !ifsc || !accountName) {
                showNotification('Please fill in all required bank details', 'error');
                return;
            }

            // Validate UPI ID format if provided
            if (upiId) {
                const upiRegex = /^[a-zA-Z0-9.\-_]{2,256}@[a-zA-Z0-9][a-zA-Z0-9.-]{1,64}$/;
                if (!upiRegex.test(upiId)) {
                    showNotification('Please enter a valid UPI ID format', 'error');
                    return;
                }
            }

            const withdrawalDetails = {
                bankAccount: account,
                ifscCode: ifsc,
                accountName: accountName,
                upiId: upiId || null,
                method: 'netbanking'
            };

            const description = upiId ? 
                `Net Banking withdrawal to ***${account.slice(-4)} (UPI: ${upiId})` : 
                `Net Banking withdrawal to ***${account.slice(-4)}`;

            try {
                const userRef = db.collection('users').doc(currentUser.uid);

                const withdrawalTransaction = {
                    id: generateTransactionId(),
                    type: 'withdrawal',
                    amount: -amount,
                    description: description,
                    timestamp: new Date(),
                    status: 'pending_approval',
                    adminApprovalRequired: true,
                    date: new Date().toLocaleDateString('en-IN'),
                    time: new Date().toLocaleTimeString('en-IN'),
                    paymentVerified: false,
                    ...withdrawalDetails
                };

                // Create pending withdrawal for admin approval
                const pendingWithdrawal = {
                    ...withdrawalTransaction,
                    userId: currentUser.uid,
                    userEmail: currentUser.email,
                    userName: currentUser.displayName || 'Unknown User',
                    requestedAt: new Date(),
                    approvalStatus: 'pending'
                };

                const batch = db.batch();

                // Update user balance (temporarily deduct)
                batch.update(userRef, {
                    balance: firebase.firestore.FieldValue.increment(-amount),
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Add transaction to user's collection
                const transactionRef = userRef.collection('transactions').doc();
                batch.set(transactionRef, withdrawalTransaction);

                // Add to pending withdrawals collection for admin approval
                const pendingRef = db.collection('pendingWithdrawals').doc();
                batch.set(pendingRef, pendingWithdrawal);

                await batch.commit();

                // Update local state
                userBalance -= amount;
                transactions.unshift(withdrawalTransaction);
                withdrawalHistory.unshift(withdrawalTransaction);

                document.getElementById('userBalance').textContent = '₹' + userBalance.toLocaleString();
                renderTransactions();
                renderWithdrawalHistory();
                updateProfileStats();

                // Clear form
                document.getElementById('withdrawalAmount').value = '';
                document.getElementById('withdrawalAccount').value = '';
                document.getElementById('withdrawalIFSC').value = '';
                document.getElementById('withdrawalAccountName').value = '';
                document.getElementById('withdrawalUPI').value = '';

                showNotification('Withdrawal request submitted for admin approval!', 'success');

                // If user is admin, show pending withdrawals
                if (isAdmin) {
                    loadPendingWithdrawals();
                }

            } catch (error) {
                console.error('❌ Error processing withdrawal:', error);
                showNotification('Failed to process withdrawal. Please try again.', 'error');
            }
        }

        function renderWithdrawalHistory() {
            const withdrawalHistoryEl = document.getElementById('withdrawalHistory');
            if (!withdrawalHistoryEl) return;

            withdrawalHistoryEl.innerHTML = '';

            const userWithdrawals = transactions.filter(t => t.type === 'withdrawal');

            if (userWithdrawals.length === 0) {
                withdrawalHistoryEl.innerHTML = '<div class="data-item"><div class="data-item-info">No withdrawals yet</div></div>';
                return;
            }

            userWithdrawals.forEach(withdrawal => {
                const withdrawalItem = document.createElement('div');
                withdrawalItem.className = 'data-item';

                let statusBadge = '';
                let statusClass = '';
                let statusText = '';

                switch (withdrawal.status) {
                    case 'pending_approval':
                        statusClass = 'pending';
                        statusText = 'Pending Approval';
                        break;
                    case 'approved':
                        statusClass = 'approved';
                        statusText = 'Approved';
                        break;
                    case 'processing':
                        statusClass = 'processing';
                        statusText = 'Processing';
                        break;
                    case 'completed':
                        statusClass = 'verified';
                        statusText = 'Completed';
                        break;
                    case 'rejected':
                        statusClass = 'rejected';
                        statusText = 'Rejected';
                        break;
                    default:
                        statusClass = 'pending';
                        statusText = 'Processing';
                }

                statusBadge = `<span class="payment-verification-badge ${statusClass}">${statusText}</span>`;

                withdrawalItem.innerHTML = `
                    <div class="data-item-info">
                        <div class="data-item-title">${withdrawal.description}${statusBadge}</div>
                        <div class="data-item-subtitle">${withdrawal.date} • ${withdrawal.time}</div>
                    </div>
                    <div class="data-item-value transaction-amount negative">
                        -₹${Math.abs(withdrawal.amount).toLocaleString()}
                    </div>
                `;
                withdrawalHistoryEl.appendChild(withdrawalItem);
            });
        }

        // Modal functions
        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'block';

            // Pre-fill email if user is logged in
            if (modalId === 'addMoneyModal' && currentUser) {
                document.getElementById('paymentEmail').value = currentUser.email;
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Payment functions
        function setAmount(amount) {
            document.getElementById('amountInput').value = amount;
            updatePaymentSummary();
        }

        function selectUPIMethod(method) {
            // Remove selected class from all options
            document.querySelectorAll('.upi-option').forEach(option => {
                option.classList.remove('selected');
            });

            // Add selected class to clicked option
            event.currentTarget.classList.add('selected');

            // Check the radio button
            document.querySelector(`input[value="${method}"]`).checked = true;
            currentPaymentMethod = method;
        }

        function updatePaymentSummary() {
            const amount = parseInt(document.getElementById('amountInput').value) || 0;
            const actualDepositAmount = Math.floor(amount * 0.98); // 98% goes to wallet, 2% for gateway fees

            document.getElementById('paymentAmount').textContent = '₹' + actualDepositAmount.toLocaleString();
            document.getElementById('totalAmount').textContent = '₹' + amount.toLocaleString();
            currentPaymentAmount = actualDepositAmount;
        }

        async function handlePayment() {
            const email = document.getElementById('paymentEmail')?.value.trim();
            if (!email) {
                showNotification('Please enter your email for payment receipt.', 'error');
                return;
            }

            const amount = parseInt(document.getElementById('amountInput').value);

            if (!amount || amount < 10) {
                showNotification('Please enter a valid amount (minimum ₹10)', 'error');
                return;
            }

            if (amount > 50000) {
                showNotification('Maximum amount allowed is ₹50,000', 'error');
                return;
            }

            if (!currentUser) {
                showNotification('Please login first', 'error');
                return;
            }

            const selectedUPIMethod = document.querySelector('input[name="upiMethod"]:checked').value;
            
            // User pays exact amount they entered
            // Platform internally calculates actual amount after deducting 2% gateway fee
            const userPayAmount = amount; // What user pays
            const actualDepositAmount = Math.floor(amount * 0.98); // What gets added to wallet (98% of payment)
            
            currentPaymentAmount = actualDepositAmount; // Store the actual deposit amount
            currentPaymentMethod = selectedUPIMethod;

            try {
                showNotification('Initiating payment verification...', 'success');

                if (selectedUPIMethod === 'upi') {
                    // Show UPI QR code modal
                    closeModal('addMoneyModal');
                    showUPIPayment(userPayAmount);
                } else {
                    // Try Cashfree integration with payment verification
                    try {
                
                const response = await fetch(`${API_BASE_URL}/create-payment-order`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                amount: userPayAmount, // User pays this amount
                                depositAmount: actualDepositAmount, // This gets added to wallet
                                userId: currentUser.uid,
                                userEmail: email,
                                upiMethod: selectedUPIMethod
                            })
                        });

                        if (response.ok) {
                            const orderData = await response.json();

                            if (cashfree && orderData.payment_session_id) {
                                const checkoutOptions = {
                                    paymentSessionId: orderData.payment_session_id,
                                    redirectTarget: "_modal"
                                };

                                const result = await cashfree.checkout(checkoutOptions);

                                if (result.error) {
                                    throw new Error(result.error.message || 'Payment failed');
                                } else if (result.paymentDetails && result.paymentDetails.paymentStatus === 'SUCCESS') {
                                    await verifyAndProcessPayment(actualDepositAmount, result.paymentDetails.paymentId);
                                }
                            } else {
                                throw new Error('Cashfree not available');
                            }
                        } else {
                            throw new Error('API not available');
                        }
                    } catch (apiError) {
                        console.log('API/Cashfree not available, using manual verification');
                        closeModal('addMoneyModal');
                        showUPIPayment(userPayAmount);
                    }
                }

            } catch (error) {
                console.error('❌ Payment error:', error);
                showNotification('Payment initiation failed. Please try again.', 'error');
            }
        }

        async function verifyAndProcessPayment(amount, paymentId) {
            try {
                // In production, verify payment with Cashfree API
                const verificationResponse = await fetch(`${API_BASE_URL}/verify-payment`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        paymentId: paymentId,
                        userId: currentUser.uid,
                        amount: amount,
                        totalPaid: amount
                    })
                });

                if (verificationResponse.ok) {
                    const verification = await verificationResponse.json();
                    if (verification.verified) {
                        await handlePaymentSuccess(amount, paymentId || orderId);
                    } else {
                        showNotification('Payment verification failed. Please contact support.', 'error');
                    }
                } else {
                    // Fallback: process payment without backend verification (for testing)
                    await handlePaymentSuccess(amount, paymentId || orderId);
                }
            } catch (error) {
                console.error('Error verifying payment:', error);
                // Fallback: process payment without backend verification
                await handlePaymentSuccess(amount, paymentId || orderId);
            }
        }

        function showUPIPayment(amount) {
            // Generate UPI payment URL
            const upiUrl = generateUPIUrl(amount);

            // Update UPI modal content
            document.getElementById('upiAmount').textContent = '₹' + amount.toLocaleString();
            document.getElementById('upiIdDisplay').textContent = UPI_CONFIG.merchantId;

            // Generate QR code
            const qrCodeUrl = `${UPI_CONFIG.qrCodeUrl}?size=200x200&data=${encodeURIComponent(upiUrl)}`;
            document.getElementById('upiQRCode').innerHTML = `<img src="${qrCodeUrl}" alt="UPI QR Code" style="width: 100%; height: 100%; object-fit: contain;">`;

            // Show UPI modal
            openModal('upiPaymentModal');
        }

        function generateUPIUrl(amount) {
            const orderId = `LOTTERY_${Date.now()}_${currentUser.uid}`;
            return `upi://pay?pa=${UPI_CONFIG.merchantId}&pn=${encodeURIComponent(UPI_CONFIG.merchantName)}&mc=${UPI_CONFIG.merchantCode}&tid=${orderId}&tr=${orderId}&tn=${encodeURIComponent('Smart Lottery Pro Payment')}&am=${amount}&cu=INR`;
        }

        function copyUPIId() {
            navigator.clipboard.writeText(UPI_CONFIG.merchantId).then(() => {
                showNotification('UPI ID copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Failed to copy UPI ID', 'error');
            });
        }

        async function confirmUPIPayment() {
            try {
                showNotification('Processing payment verification...', 'success');

                // Close UPI modal
                closeModal('upiPaymentModal');

                // Simulate payment verification delay
                setTimeout(async () => {
                    // In production, verify payment status with payment gateway
                    // Pass the actual deposit amount (98% of what user paid)
                    await handlePaymentSuccess(currentPaymentAmount, `upi_${Date.now()}`);
                }, 2000);

            } catch (error) {
                console.error('❌ Error confirming payment:', error);
                showNotification('Failed to confirm payment. Please try again.', 'error');
            }
        }

        async function handlePaymentSuccess(depositAmount, paymentId) {
            try {
                if (!currentUser) {
                    throw new Error('User not logged in');
                }

                const userRef = db.collection('users').doc(currentUser.uid);

                const paymentTransaction = {
                    id: generateTransactionId(),
                    type: 'money_added',
                    amount: depositAmount,
                    description: `Money added via ${currentPaymentMethod.toUpperCase()}`,
                    timestamp: new Date(),
                    paymentId: paymentId || `manual_${Date.now()}`,
                    status: 'completed',
                    date: new Date().toLocaleDateString('en-IN'),
                    time: new Date().toLocaleTimeString('en-IN'),
                    paymentVerified: true,
                    paymentMethod: currentPaymentMethod,
                    email: document.getElementById('paymentEmail')?.value || currentUser.email
                };

                // Update user balance and profile in Firestore
                const batch = db.batch();

                batch.update(userRef, {
                    balance: firebase.firestore.FieldValue.increment(depositAmount),
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Add transaction to sub-collection
                const transactionRef = userRef.collection('transactions').doc();
                batch.set(transactionRef, paymentTransaction);

                await batch.commit();

                // Update local state immediately
                userBalance += depositAmount;
                transactions.unshift(paymentTransaction);

                // Update all UI elements
                document.getElementById('userBalance').textContent = '₹' + userBalance.toLocaleString();
                updateProfileStats();
                renderTransactions();

                // Force refresh user data from Firestore
                try {
                    const refreshedUserDoc = await db.collection('users').doc(currentUser.uid).get();
                    if (refreshedUserDoc.exists) {
                        const refreshedData = refreshedUserDoc.data();
                        userBalance = refreshedData.balance || userBalance;
                        userProfile = {
                            contestsJoined: refreshedData.contestsJoined || 0,
                            contestsWon: refreshedData.contestsWon || 0,
                            totalWinnings: refreshedData.totalWinnings || 0
                        };
                        
                        // Update UI again with fresh data
                        document.getElementById('userBalance').textContent = '₹' + userBalance.toLocaleString();
                        updateProfileStats();
                        
                        // Reload transactions from Firestore
                        const transactionsSnapshot = await db.collection('users').doc(currentUser.uid)
                            .collection('transactions').orderBy('timestamp', 'desc').limit(50).get();
                        
                        if (!transactionsSnapshot.empty) {
                            transactions = transactionsSnapshot.docs.map(doc => {
                                const data = doc.data();
                                return {
                                    id: doc.id,
                                    ...data,
                                    timestamp: data.timestamp && data.timestamp.toDate ? data.timestamp.toDate() : data.timestamp
                                };
                            });
                            renderTransactions();
                        }
                    }
                } catch (refreshError) {
                    console.log('Error refreshing user data:', refreshError);
                }

                // Clear form
                document.getElementById('amountInput').value = '';
                document.getElementById('paymentEmail').value = '';
                updatePaymentSummary();

                // Close modals
                closeModal('addMoneyModal');
                closeModal('upiPaymentModal');

                showNotification(`✅ Payment verified! ₹${depositAmount.toLocaleString()} added to your wallet.`, 'success');

            } catch (error) {
                console.error('❌ Error processing payment success:', error);
                showNotification('Payment verification failed. Please contact support with payment ID: ' + paymentId, 'error');
            }
        }

        // Notification function
        function showNotification(message, type = 'success') {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => notification.remove());

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <i class="fas ${type === 'success' ? 'fa-check-circle' : 'fa-exclamation-circle'}"></i>
                <span>${message}</span>
            `;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 5000);
        }

        // Enhanced Admin Functions
        async function adminDeclareResults(contestId) {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            if (!confirm('Are you sure you want to declare results for this contest? This action cannot be undone.')) {
                return;
            }

            try {
                showNotification('Admin declaring contest results...', 'success');
                
                // Force the contest to ended status first
                const contest = activeContests.find(c => c.id === contestId);
                if (contest) {
                    contest.status = 'ended';
                    contest.endedAt = new Date();
                    contest.endingInProgress = false; // Reset this flag
                }
                
                // Call the automatic winner declaration function
                await declareAutomaticWinners(contestId);
                
                showNotification('Contest results declared successfully!', 'success');
                renderAdminContests();
                renderContests(activeContests);
            } catch (error) {
                console.error('Error in admin declare results:', error);
                showNotification('Failed to declare results. Please try again.', 'error');
            }
        }

        async function viewContestParticipants(contestId) {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            try {
                showNotification('Loading participants...', 'success');
                
                const contest = CONTEST_TEMPLATES.find(c => c.id === contestId);
                if (!contest) {
                    showNotification('Contest not found', 'error');
                    return;
                }

                // Get all participants for this contest from Firestore
                const usersSnapshot = await db.collection('users').get();
                const participants = [];

                usersSnapshot.forEach(doc => {
                    const userData = doc.data();
                    const userJoinedContests = userData.joinedContests || [];
                    const contestEntry = userJoinedContests.find(jc => jc.contestId === contestId);

                    if (contestEntry) {
                        participants.push({
                            uid: doc.id,
                            displayName: userData.displayName || 'Unknown User',
                            email: userData.email || 'No email',
                            joinedDate: contestEntry.joinedDate || 'Unknown',
                            joinedTime: contestEntry.joinedTime || 'Unknown',
                            status: contestEntry.status || 'joined',
                            prizeWon: contestEntry.prizeWon || 0,
                            position: contestEntry.position || null
                        });
                    }
                });

                // Create participants modal
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h2>Contest Participants - ${contest.title}</h2>
                            <button class="modal-close" onclick="this.closest('.modal').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 20px; padding: 15px; background: var(--background); border-radius: var(--radius);">
                                <strong>Total Participants: ${participants.length}</strong>
                            </div>
                            <div style="max-height: 400px; overflow-y: auto;">
                                ${participants.length === 0 ? 
                                    '<p style="text-align: center; color: var(--text-light); padding: 40px;">No participants yet</p>' :
                                    participants.map((participant, index) => `
                                        <div style="padding: 15px; border: 1px solid var(--border); border-radius: var(--radius); margin-bottom: 10px; background: var(--surface);">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <div>
                                                    <div style="font-weight: 600; color: var(--text);">${index + 1}. ${participant.displayName}</div>
                                                    <div style="font-size: 0.9rem; color: var(--text-light);">${participant.email}</div>
                                                    <div style="font-size: 0.85rem; color: var(--text-light);">Joined: ${participant.joinedDate} at ${participant.joinedTime}</div>
                                                </div>
                                                <div style="text-align: right;">
                                                    <div style="padding: 4px 8px; border-radius: 12px; font-size: 0.8rem; font-weight: 600; 
                                                                background: ${participant.status === 'won' ? 'rgba(245, 158, 11, 0.1)' : 
                                                                           participant.status === 'completed' ? 'rgba(100, 116, 139, 0.1)' : 'rgba(16, 185, 129, 0.1)'};
                                                                color: ${participant.status === 'won' ? 'var(--warning)' : 
                                                                        participant.status === 'completed' ? 'var(--secondary)' : 'var(--success)'};">
                                                        ${participant.status === 'won' ? `Won ${participant.position}` : 
                                                          participant.status === 'completed' ? 'No Prize' : 'Active'}
                                                    </div>
                                                    ${participant.prizeWon > 0 ? `<div style="font-size: 0.9rem; color: var(--success); font-weight: 600; margin-top: 5px;">₹${participant.prizeWon.toLocaleString()}</div>` : ''}
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')
                                }
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
                showNotification(`Loaded ${participants.length} participants`, 'success');

            } catch (error) {
                console.error('Error viewing participants:', error);
                showNotification('Failed to load participants', 'error');
            }
        }

        function editContestDetails(contestId) {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) {
                showNotification('Contest not found', 'error');
                return;
            }

            if (contest.status === 'completed') {
                showNotification('Cannot edit completed contest', 'error');
                return;
            }

            // Create edit modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Edit Contest - ${contest.title}</h2>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Contest Title</label>
                            <input type="text" class="form-input" id="editContestTitle" value="${contest.title}">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Entry Fee (₹)</label>
                            <input type="number" class="form-input" id="editEntryFee" value="${contest.entryFee}" min="1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Max Participants</label>
                            <input type="number" class="form-input" id="editMaxParticipants" value="${contest.maxParticipants}" min="${contest.currentParticipants}">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Prize Pool (₹)</label>
                            <input type="number" class="form-input" id="editPrizePool" value="${contest.prizePool}" min="1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">End Time</label>
                            <input type="datetime-local" class="form-input" id="editEndTime" 
                                   value="${new Date(contest.endTime).toISOString().slice(0, -8)}">
                        </div>
                        <button class="btn btn-primary btn-full" onclick="saveContestChanges('${contestId}')">
                            <i class="fas fa-save"></i> Save Changes
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function saveContestChanges(contestId) {
            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) return;

            const title = document.getElementById('editContestTitle').value.trim();
            const entryFee = parseInt(document.getElementById('editEntryFee').value);
            const maxParticipants = parseInt(document.getElementById('editMaxParticipants').value);
            const prizePool = parseInt(document.getElementById('editPrizePool').value);
            const endTime = new Date(document.getElementById('editEndTime').value);

            if (!title || !entryFee || !maxParticipants || !prizePool || !endTime) {
                showNotification('Please fill all fields correctly', 'error');
                return;
            }

            if (maxParticipants < contest.currentParticipants) {
                showNotification('Max participants cannot be less than current participants', 'error');
                return;
            }

            // Update contest
            contest.title = title;
            contest.entryFee = entryFee;
            contest.maxParticipants = maxParticipants;
            contest.prizePool = prizePool;
            contest.endTime = endTime;

            // Recalculate prize structure proportionally
            const totalPrize = prizePool;
            contest.prizeStructure = [
                { position: '1st Prize', amount: Math.floor(totalPrize * 0.5), percentage: '50%' },
                { position: '2nd Prize', amount: Math.floor(totalPrize * 0.25), percentage: '25%' },
                { position: '3rd Prize', amount: Math.floor(totalPrize * 0.15), percentage: '15%' },
                { position: 'Consolation (10 winners)', amount: Math.floor(totalPrize * 0.1 / 10), percentage: '10%' }
            ];

            document.querySelector('.modal').remove();
            renderAdminContests();
            showNotification('Contest updated successfully!', 'success');
        }

        function pauseContest(contestId) {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            const contest = activeContests.find(c => c.id === contestId);
            if (contest) {
                contest.status = contest.status === 'paused' ? 'active' : 'paused';
                renderAdminContests();
                showNotification(`Contest ${contest.status === 'paused' ? 'paused' : 'resumed'} successfully!`, 'success');
            }
        }

        function forceEndContest(contestId) {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            if (!confirm('Are you sure you want to force end this contest? This will allow result declaration immediately.')) {
                return;
            }

            const contest = activeContests.find(c => c.id === contestId);
            if (contest && contest.status !== 'completed') {
                contest.status = 'ready_for_declaration';
                contest.endTime = new Date(); // Set end time to now
                renderAdminContests();
                showNotification('Contest force-ended. You can now declare results.', 'success');
            }
        }

        function createNewContest() {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            // Create new contest modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Create New Contest</h2>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Contest Title</label>
                            <input type="text" class="form-input" id="newContestTitle" placeholder="Enter contest name">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Entry Fee (₹)</label>
                            <input type="number" class="form-input" id="newEntryFee" placeholder="Enter entry fee" min="1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Max Participants</label>
                            <input type="number" class="form-input" id="newMaxParticipants" placeholder="Enter max participants" min="10">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Prize Pool (₹)</label>
                            <input type="number" class="form-input" id="newPrizePool" placeholder="Enter total prize pool" min="100">
                        </div>
                        <div class="form-group">
                            <label class="form-label">End Date</label>
                            <input type="date" class="form-input" id="newEndDate" placeholder="Enter end date">
                        </div>
                        <div class="form-group">
                            <label class="form-label">End Time</label>
                            <input type="time" class="form-input" id="newEndTime" placeholder="Enter end time">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Description</label>
                            <textarea class="form-input" id="newDescription" placeholder="Enter contest description" rows="3"></textarea>
                        </div>
                        <button class="btn btn-success btn-full" onclick="saveNewContest()">
                            <i class="fas fa-plus"></i> Create Contest
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function switchAdminTab(tabName) {
            // Update button states
            document.getElementById('adminContestsBtn').style.background = 'transparent';
            document.getElementById('adminContestsBtn').style.color = 'var(--primary)';
            document.getElementById('adminWithdrawalsBtn').style.background = 'transparent';
            document.getElementById('adminWithdrawalsBtn').style.color = 'var(--primary)';

            // Hide all sections
            document.getElementById('adminContestsSection').style.display = 'none';
            document.getElementById('adminWithdrawalsSection').style.display = 'none';

            if (tabName === 'contests') {
                document.getElementById('adminContestsBtn').style.background = 'var(--primary)';
                document.getElementById('adminContestsBtn').style.color = 'white';
                document.getElementById('adminContestsSection').style.display = 'block';
                renderAdminContests();
            } else if (tabName === 'withdrawals') {
                document.getElementById('adminWithdrawalsBtn').style.background = 'var(--primary)';
                document.getElementById('adminWithdrawalsBtn').style.color = 'white';
                document.getElementById('adminWithdrawalsSection').style.display = 'block';
                loadPendingWithdrawals();
            }
        }

        async function loadPendingWithdrawals() {
            if (!isAdmin) return;

            try {
                const pendingSnapshot = await db.collection('pendingWithdrawals')
                    .where('approvalStatus', '==', 'pending')
                    .orderBy('requestedAt', 'desc')
                    .get();

                pendingWithdrawals = [];
                pendingSnapshot.forEach(doc => {
                    pendingWithdrawals.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });

                renderPendingWithdrawals();
            } catch (error) {
                console.error('Error loading pending withdrawals:', error);
                showNotification('Failed to load pending withdrawals', 'error');
            }
        }

        function renderPendingWithdrawals() {
            const adminWithdrawalsList = document.getElementById('adminWithdrawalsList');
            if (!adminWithdrawalsList) return;

            adminWithdrawalsList.innerHTML = '';

            if (pendingWithdrawals.length === 0) {
                adminWithdrawalsList.innerHTML = `
                    <div style="text-align: center; padding: 40px; background: var(--surface); border-radius: var(--radius-lg); box-shadow: var(--shadow);">
                        <i class="fas fa-check-circle" style="font-size: 3rem; margin-bottom: 20px; color: var(--success); opacity: 0.5;"></i>
                        <h3 style="color: var(--text); margin-bottom: 10px;">No Pending Withdrawals</h3>
                        <p style="color: var(--text-light);">All withdrawal requests have been processed</p>
                    </div>
                `;
                return;
            }

            pendingWithdrawals.forEach(withdrawal => {
                const withdrawalCard = document.createElement('div');
                withdrawalCard.style.marginBottom = '20px';
                withdrawalCard.style.padding = '25px';
                withdrawalCard.style.background = 'var(--surface)';
                withdrawalCard.style.borderRadius = 'var(--radius-lg)';
                withdrawalCard.style.boxShadow = 'var(--shadow)';
                withdrawalCard.style.border = '2px solid var(--warning)';

                const methodIcon = withdrawal.method === 'upi' ? 'fa-mobile-alt' : 'fa-university';
                const methodColor = withdrawal.method === 'upi' ? '#5f2c8e' : '#007bff';

                withdrawalCard.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <i class="fas ${methodIcon}" style="color: ${methodColor}; font-size: 1.5rem;"></i>
                                <div>
                                    <div style="font-size: 1.3rem; font-weight: 700; color: var(--primary);">₹${Math.abs(withdrawal.amount).toLocaleString()}</div>
                                    <div style="font-size: 0.9rem; color: var(--text-light);">${withdrawal.method.toUpperCase()} Withdrawal</div>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.85rem; color: var(--text-light);">Request ID</div>
                                <div style="font-size: 0.9rem; font-weight: 600; color: var(--text);">${withdrawal.id.slice(-8)}</div>
                            </div>
                        </div>

                        <div style="background: var(--background); padding: 20px; border-radius: var(--radius); margin-bottom: 20px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 15px;">
                                <div>
                                    <div style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 5px;">User Details</div>
                                    <div style="font-weight: 600; color: var(--text);">${withdrawal.userName}</div>
                                    <div style="font-size: 0.9rem; color: var(--text-light);">${withdrawal.userEmail}</div>
                                </div>
                                <div>
                                    <div style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 5px;">Request Time</div>
                                    <div style="font-weight: 600; color: var(--text);">${withdrawal.date}</div>
                                    <div style="font-size: 0.9rem; color: var(--text-light);">${withdrawal.time}</div>
                                </div>
                            </div>

                            ${withdrawal.method === 'bank' ? `
                                <div style="border-top: 1px solid var(--border); padding-top: 15px;">
                                    <div style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 8px;">Bank Details</div>
                                    <div style="font-size: 0.9rem; color: var(--text); margin-bottom: 5px;"><strong>Account:</strong> ***${withdrawal.bankAccount.slice(-4)}</div>
                                    <div style="font-size: 0.9rem; color: var(--text); margin-bottom: 5px;"><strong>IFSC:</strong> ${withdrawal.ifscCode}</div>
                                    <div style="font-size: 0.9rem; color: var(--text);"><strong>Name:</strong> ${withdrawal.accountName}</div>
                                </div>
                            ` : `
                                <div style="border-top: 1px solid var(--border); padding-top: 15px;">
                                    <div style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 8px;">UPI Details</div>
                                    <div style="font-size: 0.9rem; color: var(--text); margin-bottom: 5px;"><strong>UPI ID:</strong> ${withdrawal.upiId}</div>
                                    <div style="font-size: 0.9rem; color: var(--text);"><strong>Name:</strong> ${withdrawal.upiName}</div>
                                </div>
                            `}
                        </div>

                        <div style="display: flex; gap: 15px;">
                            <button class="btn btn-success" onclick="approveWithdrawal('${withdrawal.id}')" style="flex: 1;">
                                <i class="fas fa-check"></i> Approve
                            </button>
                            <button class="btn btn-outline" onclick="rejectWithdrawal('${withdrawal.id}')" style="flex: 1; border-color: var(--error); color: var(--error);">
                                <i class="fas fa-times"></i> Reject
                            </button>
                            <button class="btn btn-secondary" onclick="viewUserDetails('${withdrawal.userId}')" style="flex: 1;">
                                <i class="fas fa-user"></i> View User
                            </button>
                        </div>
                    </div>
                `;
                adminWithdrawalsList.appendChild(withdrawalCard);
            });
        }

        async function approveWithdrawal(withdrawalId) {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            if (!confirm('Are you sure you want to approve this withdrawal? This action cannot be undone.')) {
                return;
            }

            try {
                const withdrawal = pendingWithdrawals.find(w => w.id === withdrawalId);
                if (!withdrawal) return;

                const batch = db.batch();

                // Update pending withdrawal status
                const pendingRef = db.collection('pendingWithdrawals').doc(withdrawalId);
                batch.update(pendingRef, {
                    approvalStatus: 'approved',
                    approvedBy: currentUser.email,
                    approvedAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Update user's transaction
                const userRef = db.collection('users').doc(withdrawal.userId);
                const transactionsSnapshot = await userRef.collection('transactions')
                    .where('id', '==', withdrawal.id)
                    .get();

                if (!transactionsSnapshot.empty) {
                    const transactionDoc = transactionsSnapshot.docs[0];
                    batch.update(transactionDoc.ref, {
                        status: 'approved',
                        approvedBy: currentUser.email,
                        approvedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }

                await batch.commit();

                showNotification('Withdrawal approved successfully!', 'success');
                loadPendingWithdrawals();

            } catch (error) {
                console.error('Error approving withdrawal:', error);
                showNotification('Failed to approve withdrawal', 'error');
            }
        }

        async function rejectWithdrawal(withdrawalId) {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            const reason = prompt('Please enter reason for rejection (optional):');
            if (reason === null) return; // User cancelled

            try {
                const withdrawal = pendingWithdrawals.find(w => w.id === withdrawalId);
                if (!withdrawal) return;

                const batch = db.batch();

                // Update pending withdrawal status
                const pendingRef = db.collection('pendingWithdrawals').doc(withdrawalId);
                batch.update(pendingRef, {
                    approvalStatus: 'rejected',
                    rejectedBy: currentUser.email,
                    rejectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    rejectionReason: reason || 'No reason provided'
                });

                // Refund user's balance
                const userRef = db.collection('users').doc(withdrawal.userId);
                batch.update(userRef, {
                    balance: firebase.firestore.FieldValue.increment(Math.abs(withdrawal.amount))
                });

                // Update user's transaction
                const transactionsSnapshot = await userRef.collection('transactions')
                    .where('id', '==', withdrawal.id)
                    .get();

                if (!transactionsSnapshot.empty) {
                    const transactionDoc = transactionsSnapshot.docs[0];
                    batch.update(transactionDoc.ref, {
                        status: 'rejected',
                        rejectedBy: currentUser.email,
                        rejectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        rejectionReason: reason || 'No reason provided'
                    });
                }

                await batch.commit();

                showNotification('Withdrawal rejected and amount refunded to user', 'success');
                loadPendingWithdrawals();

            } catch (error) {
                console.error('Error rejecting withdrawal:', error);
                showNotification('Failed to reject withdrawal', 'error');
            }
        }

        async function viewUserDetails(userId) {
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (!userDoc.exists) {
                    showNotification('User not found', 'error');
                    return;
                }

                const userData = userDoc.data();

                // Create user details modal
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>User Details</h2>
                            <button class="modal-close" onclick="this.closest('.modal').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div style="text-align: center; margin-bottom: 20px;">
                                <div style="width: 80px; height: 80px; background: var(--primary); color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 2rem; font-weight: 700; margin: 0 auto 15px;">
                                    ${(userData.displayName || 'U')[0].toUpperCase()}
                                </div>
                                <h3 style="margin: 0; color: var(--text);">${userData.displayName || 'Unknown User'}</h3>
                                <p style="margin: 5px 0 0 0; color: var(--text-light);">${userData.email}</p>
                            </div>

                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 20px;">
                                <div style="text-align: center; padding: 15px; background: var(--background); border-radius: var(--radius);">
                                    <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary);">₹${(userData.balance || 0).toLocaleString()}</div>
                                    <div style="font-size: 0.9rem; color: var(--text-light);">Current Balance</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: var(--background); border-radius: var(--radius);">
                                    <div style="font-size: 1.5rem; font-weight: 700; color: var(--success);">₹${(userData.totalWinnings || 0).toLocaleString()}</div>
                                    <div style="font-size: 0.9rem; color: var(--text-light);">Total Winnings</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: var(--background); border-radius: var(--radius);">
                                    <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary);">${userData.contestsJoined || 0}</div>
                                    <div style="font-size: 0.9rem; color: var(--text-light);">Contests Joined</div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: var(--background); border-radius: var(--radius);">
                                    <div style="font-size: 1.5rem; font-weight: 700; color: var(--warning);">${userData.contestsWon || 0}</div>
                                    <div style="font-size: 0.9rem; color: var(--text-light);">Contests Won</div>
                                </div>
                            </div>

                            <div style="padding: 15px; background: var(--background); border-radius: var(--radius);">
                                <div style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 5px;">Account Created</div>
                                <div style="font-weight: 600; color: var(--text);">${userData.createdAt ? new Date(userData.createdAt.toDate()).toLocaleDateString('en-IN') : 'Unknown'}</div>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

            } catch (error) {
                console.error('Error viewing user details:', error);
                showNotification('Failed to load user details', 'error');
            }
        }

        function saveNewContest() {
            const title = document.getElementById('newContestTitle').value.trim();
            const entryFee = parseInt(document.getElementById('newEntryFee').value);
            const maxParticipants = parseInt(document.getElementById('newMaxParticipants').value);
            const prizePool = parseInt(document.getElementById('newPrizePool').value);
            const endDate = document.getElementById('newEndDate').value;
            const endTime = document.getElementById('newEndTime').value;
            const description = document.getElementById('newDescription').value.trim();

            if (!title || !entryFee || !maxParticipants || !prizePool || !endDate || !endTime) {
                showNotification('Please fill all required fields', 'error');
                return;
            }

            // Create fixed end time from date and time
            const endDateTime = new Date(`${endDate}T${endTime}:00`);
            
            if (endDateTime <= new Date()) {
                showNotification('End date and time must be in the future', 'error');
                return;
            }

            // Generate new contest
            const newContest = {
                id: 'custom_' + Date.now(),
                title: title,
                entryFee: entryFee,
                maxParticipants: maxParticipants,
                prizePool: prizePool,
                endDate: endDate,
                endTime: endTime,
                description: description || 'Custom contest created by admin',
                currentParticipants: 0,
                endTime: endDateTime,
                status: 'active',
                participants: [],
                createdAt: new Date(),
                isActive: true,
                prizeStructure: [
                    { position: '1st Prize', amount: Math.floor(prizePool * 0.5), percentage: '50%' },
                    { position: '2nd Prize', amount: Math.floor(prizePool * 0.25), percentage: '25%' },
                    { position: '3rd Prize', amount: Math.floor(prizePool * 0.15), percentage: '15%' },
                    { position: 'Consolation (10 winners)', amount: Math.floor(prizePool * 0.1 / 10), percentage: '10%' }
                ]
            };

            activeContests.unshift(newContest);
            document.querySelector('.modal').remove();
            renderContests(activeContests);
            renderAdminContests();
            showNotification('New contest created successfully!', 'success');
        }

        function manageAllContests() {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            showNotification('Contest management dashboard coming soon!', 'success');
        }

        function exportContestData() {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            const data = {
                contests: activeContests,
                timestamp: new Date().toISOString(),
                totalContests: activeContests.length,
                totalParticipants: activeContests.reduce((sum, c) => sum + c.currentParticipants, 0)
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lottery_data_${new Date().getTime()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showNotification('Contest data exported successfully!', 'success');
        }

        function adminSettings() {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            showNotification('Admin settings panel coming soon!', 'success');
        }

        async function adminEndContest(contestId) {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) {
                showNotification('Contest not found', 'error');
                return;
            }

            if (contest.status !== 'active') {
                showNotification('Contest is already ended', 'error');
                return;
            }

            if (!confirm(`Are you sure you want to end "${contest.title}" contest now? This will allow result declaration immediately.`)) {
                return;
            }

            try {
                showNotification('Ending contest...', 'success');

                // Update contest status
                contest.status = 'ended';
                contest.endTime = new Date(); // Set end time to now
                contest.adminEnded = true;
                contest.endedBy = currentUser.email;

                // Update in Firestore
                await db.collection('activeContests').doc(contestId).update({
                    status: 'ended',
                    endTime: firebase.firestore.FieldValue.serverTimestamp(),
                    adminEnded: true,
                    endedBy: currentUser.email,
                    endedAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Re-render contests
                renderContests(activeContests);
                if (isAdmin) {
                    renderAdminContests();
                }

                showNotification(`✅ Contest "${contest.title}" has been ended. You can now declare results.`, 'success');

                // Show popup to declare results
                setTimeout(() => {
                    if (confirm('Contest ended successfully! Do you want to declare winners now?')) {
                        declareContestResults(contestId);
                    }
                }, 1000);

            } catch (error) {
                console.error('Error ending contest:', error);
                showNotification('Failed to end contest. Please try again.', 'error');
            }
        }

        async function adminRestartContest(contestId) {
            if (!isAdmin) {
                showNotification('Access denied: Admin privileges required', 'error');
                return;
            }

            const contest = activeContests.find(c => c.id === contestId);
            if (!contest) {
                showNotification('Contest not found', 'error');
                return;
            }

            if (!confirm(`Are you sure you want to restart "${contest.title}" contest? This will create a fresh contest cycle.`)) {
                return;
            }

            try {
                showNotification('Restarting contest...', 'success');

                const template = CONTEST_TEMPLATES.find(t => t.id === contest.id);
                if (!template) {
                    showNotification('Contest template not found', 'error');
                    return;
                }

                // Calculate new end time based on contest schedule
                const newEndTime = calculateNextDrawTime(template);
                const cycleNumber = (contest.cycleNumber || 0) + 1;

                const restartedContest = {
                    ...template,
                    currentParticipants: Math.floor(Math.random() * 20) + 5, // Start with some participants
                    endTime: newEndTime,
                    status: 'active',
                    participants: [],
                    createdAt: new Date(),
                    isActive: true,
                    cycleNumber: cycleNumber,
                    title: `${template.title} - Cycle ${cycleNumber}`,
                    lastRestart: new Date(),
                    adminRestarted: true,
                    restartedBy: currentUser.email
                };

                // Replace the old contest with the new one
                const contestIndex = activeContests.findIndex(c => c.id === contestId);
                if (contestIndex !== -1) {
                    activeContests[contestIndex] = restartedContest;
                }

                // Save to Firestore
                await db.collection('activeContests').doc(contestId).set(restartedContest);

                // Re-render contests
                renderContests(activeContests);
                if (isAdmin) {
                    renderAdminContests();
                }

                showNotification(`✅ Contest "${template.title}" has been restarted! New cycle ${cycleNumber} is now active.`, 'success');

            } catch (error) {
                console.error('Error restarting contest:', error);
                showNotification('Failed to restart contest. Please try again.', 'error');
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }
    

// === Updated Payment & Withdrawal Logic ===

// ✅ Updated sections to apply your requested changes
// 1. Remove processing fee completely
// 2. Ensure withdrawal requests are sent
// 3. Fix withdrawals showing in transactions

function updatePaymentSummary() {
  const amount = parseFloat(document.getElementById('amountInput').value) || 0;
  document.getElementById('paymentAmount').textContent = `₹${amount.toLocaleString()}`;
  document.getElementById('totalAmount').textContent = `₹${amount.toLocaleString()}`;
  currentPaymentAmount = amount;
}

async function handleWithdrawal() {
            if (!currentUser) {
                showNotification('Please login first', 'error');
                return;
            }

            const amount = parseInt(document.getElementById('withdrawalAmount').value);

            if (!amount || amount < 500) {
                showNotification('Minimum withdrawal amount is ₹500', 'error');
                return;
            }

            if (amount > userBalance) {
                showNotification('Insufficient balance', 'error');
                return;
            }

            const account = document.getElementById('withdrawalAccount').value.trim();
            const ifsc = document.getElementById('withdrawalIFSC').value.trim();
            const accountName = document.getElementById('withdrawalAccountName').value.trim();
            const upiId = document.getElementById('withdrawalUPI').value.trim();

            if (!account || !ifsc || !accountName) {
                showNotification('Please fill in all required bank details', 'error');
                return;
            }

            // Validate UPI ID format if provided
            if (upiId) {
                const upiRegex = /^[a-zA-Z0-9.\-_]{2,256}@[a-zA-Z0-9][a-zA-Z0-9.-]{1,64}$/;
                if (!upiRegex.test(upiId)) {
                    showNotification('Please enter a valid UPI ID format', 'error');
                    return;
                }
            }

            const withdrawalDetails = {
                bankAccount: account,
                ifscCode: ifsc,
                accountName: accountName,
                upiId: upiId || null,
                method: 'netbanking'
            };

            const description = upiId ? 
                `Net Banking withdrawal to ***${account.slice(-4)} (UPI: ${upiId})` : 
                `Net Banking withdrawal to ***${account.slice(-4)}`;

            try {
                showNotification('Processing withdrawal request...', 'success');
                
                const userRef = db.collection('users').doc(currentUser.uid);

                const withdrawalTransaction = {
                    id: generateTransactionId(),
                    type: 'withdrawal',
                    amount: -amount,
                    description: description,
                    timestamp: new Date(),
                    status: 'pending_approval',
                    adminApprovalRequired: true,
                    date: new Date().toLocaleDateString('en-IN'),
                    time: new Date().toLocaleTimeString('en-IN'),
                    paymentVerified: false,
                    ...withdrawalDetails
                };

                // Create pending withdrawal for admin approval
                const pendingWithdrawal = {
                    ...withdrawalTransaction,
                    userId: currentUser.uid,
                    userEmail: currentUser.email,
                    userName: currentUser.displayName || 'Unknown User',
                    requestedAt: new Date(),
                    approvalStatus: 'pending'
                };

                const batch = db.batch();

                // Update user balance (temporarily deduct)
                batch.update(userRef, {
                    balance: firebase.firestore.FieldValue.increment(-amount),
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Add transaction to user's collection
                const transactionRef = userRef.collection('transactions').doc();
                batch.set(transactionRef, withdrawalTransaction);

                // Add to pending withdrawals collection for admin approval
                const pendingRef = db.collection('pendingWithdrawals').doc();
                batch.set(pendingRef, pendingWithdrawal);

                await batch.commit();

                // Update local state
                userBalance -= amount;
                transactions.unshift(withdrawalTransaction);
                withdrawalHistory.unshift(withdrawalTransaction);

                document.getElementById('userBalance').textContent = '₹' + userBalance.toLocaleString();
                renderTransactions();
                renderWithdrawalHistory();
                updateProfileStats();

                // Clear form
                document.getElementById('withdrawalAmount').value = '';
                document.getElementById('withdrawalAccount').value = '';
                document.getElementById('withdrawalIFSC').value = '';
                document.getElementById('withdrawalAccountName').value = '';
                document.getElementById('withdrawalUPI').value = '';

                showNotification('✅ Withdrawal request submitted for admin approval!', 'success');

                // If user is admin, show pending withdrawals
                if (isAdmin) {
                    loadPendingWithdrawals();
                }

            } catch (error) {
                console.error('❌ Error processing withdrawal:', error);
                showNotification('Failed to process withdrawal. Please try again.', 'error');
            }
        }


</script>
</body>
</html>